<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IntelliJ+Gradle自定义war包名称]]></title>
    <url>%2Fidea-gradle_war%2F</url>
    <content type="text"><![CDATA[最近在帮朋友开发小程序的 Java 后端,项目采用 Gradle 构建,使用IntelliJ开发. 开发中经常需要发包到外网上,方便前端联调,而IntelliJ默认构建的 war 包名称为项目名-版本号,使得每次上传war包至服务器tomcat时还得手动重命名,发布次数多了,就显得很麻烦.这里先水一篇,简短说明下 IntelliJ中Gradle构建如何自定义war包名称. 首先打开 Project Settings 选择 Artifacts 前两个 Gradle:xxx 是创建Gradle项目并添加tomcat后,自动生成的.我们这里点击 + 新增 选择 Web Application: Archive -&gt; Empty 修改war包名称及输出路径 添加war包内容,同样选择 Artifact 选择 Gradle: xxx (exploded) 之后打包只能选择 Build -&gt; Build Artifacts 然后选择自定义的build, 然后在输出目录下即可找到war包]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IntelliJ</tag>
        <tag>war</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo绑定自定义Https域名]]></title>
    <url>%2Fhexo_ssl_netlify%2F</url>
    <content type="text"><![CDATA[通常我们将Hexo博客部署到GitHub Pages上,然后绑定自定义域名.例如作者的 GitHub Page lhalcyon.github.io绑定到了lhalcyon.com上.但是 GitHub Pages 无法给自定义域名配置SSL GitHub Pages默认是支持https的,即我们可通常https://lhalcyon.github.io来访问博客,但是绑定自定义域名后,只能通过http://lhalcyon.com正常访问,如直接访问https://lhalcyon.com就会爆红 由于博客已改造完成,就度娘了张示例图 为了实现自定义域名SSL认证,通常的做法是在Cloudflare配置一个反向代理到GitHub Pages,但是其访问速度及稳定性不太好,再就是博客更新后生效也会有延迟,于是我们得寻索一个解决办法. 为了更好的阅读体验,请点击阅读原文😉. 起初是考虑将Hexo迁移到Coding Pages上,后来发现其免费托管下必须在首页对其做一个广告,否则访问会先跳转到一个中转广告页再进行跳转 ,想免广告只能升级黄金会员及以上,这点太不友好. 问题传送门 跳转页: or 主动添加广告链接,审核过后会免去跳转页 某博客页脚添加的广告: 无疑这样大大影响我们的博客美观,不能接受,但又不想迁回GitHub Pages,怎么办?下面我们介绍一些免费及好用的静态网站托管平台 免费静态网站托管平台GitHub Pages优点 自带域名可https访问 可配置自定义域名 缺点 无法给自定义域名配置SSL Bitbucket Cloud跟 GitHub Pages 功能一样,但是: 无法自定义域名 能且只能通过 https 协议访问（http 协议会被跳转到 https 协议) 所有项目的静态网站代码都只能放在专门的站点仓库里（accountName.bitbucket.io) ,不能像 GitHub 那样可以在每个项目里用 gh-pages 分支保存文件 aerobaticBitbucket 旗下的静态网站托管服务. 可以使用 CLI 上传代码 支持自动构建 (Continuous Deployment) 可以自定义域名但是收费功能,自定义域名支持 https 且不需要提供证书,它会帮你生成一个 GitLab Pages同样和 GitHub Pages 的功能一样,但是: 自定义域名可配置https,不过需要上传证书 surge.sh 只能使用 CLI 上传代码 支持自定义域名,但开启 SSL 是收费功能且需要自行上传证书 支持200.html —— 适用于使用 History API 的 SPA Firebase Hosting 只能使用 CLI 上传代码 支持自定义域名并支持一键开启 https 支持重定向（Redirects）和重写（Rewrites）功能（当网站使用 History API 时特别有用) but 有被墙的风险…… Netlify (推荐) 可以使用 CLI 上传代码 支持自定义域名且自定义域名支持一键开启 https（证书来自 Let’s Encrype） 支持强制让用户通过 https 访问网站（开启后此功能后，http 的访问一律会 301 跳转到 https 支持自动构建 支持重定向（Redirects）和重写（Rewrites）功能 数据通过 HTTP2 协议传输 提供 webhooks 与 API now 可以使用 CLI 上传代码，或者链接一个 Git 仓库 不仅提供静态网站托管，同时也支持托管 Node.js 服务 支持自定义域名且自定义域名支持一键开启 https（证书来自 Let’s Encrype） 数据通过 HTTP2 协议传输 提供 API Coding Pages上面我们说过,收费机制甚不友好 鉴于各平台特点,我们选择Netlify Netlify部署网站首先去 Netlify 注册账号登录 接着点击页面右上角的 New site from Git 这里选择的 GitHub ,别忘记勾选访问公共仓库选项.之后授权给 Netlify 指定Repository,然后 Deploy 设置自定义域名点击 Domain settings 然后点击 Add custom domain. 然后到域名解析处,修改域名CNAME记录,记录值就是设置完域名页面显示的配置值 添加SSL证书设置完成域名绑定后,设置中心选项有所变化,增加了一个 Enable HTTPS的选项 , 点击 点击 Let’s Encrypt Certificate, 系统会自动签发证书给站点,若域名解析没问题就能签发成功 若想一直使用Https访问的话,就勾选 Force TLS connections 强制所有访问转换为Https 至此,配置全部完成 后续Netlify 还有很多技巧,比如可以设置变量及命令.免费用户可以为网站设置变量、webhook等.付费用户则可以为网站设置更加详细的SEO优化.各位可以自行去挖掘~ 🧐 参考: https://github.com/lmk123/blog/issues/55]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>SSL</tag>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC+WebSocket+Gradle实现消息实时推送]]></title>
    <url>%2Fspringmvc-websocket_im%2F</url>
    <content type="text"><![CDATA[WebSocket是HTML5开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。 WebSocket通信协议于2011年被IETF定为标准RFC 6455，WebSocketAPI被W3C定为标准。 在WebSocket API中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。 以上摘自Wikipedia. 本文将说明在Intellij IDEA下使用Gradle构建SpringMVC+WebSocket实现消息推送.为了更好的阅读体验,请点击阅读原文😉. 创建项目在之前的文章中有详细的说明,此篇不做赘述.可参考IDEA+Gradle创建MyBatis+SpringMVC项目 导入依赖在build.gradle中导入denpendies 12345678910111213// ------------------------ Spring SpringMVC start -------------------------compile group: 'org.springframework', name: 'spring-webmvc', version: '4.2.4.RELEASE'compile group: 'org.springframework', name: 'spring-context-support', version: '4.2.4.RELEASE'// ------------------------ Spring SpringMVC end -------------------------// ------------------------ WebSocket start -------------------------compile group: 'org.springframework', name: 'spring-websocket', version: '4.2.4.RELEASE'compile group: 'org.springframework', name: 'spring-messaging', version: '4.2.4.RELEASE'compile group: 'javax.servlet', name: 'javax.servlet-api', version: '3.1.0'// ------------------------ WebSocket end -------------------------compile group: 'log4j', name: 'log4j', version: '1.2.17'compile group: 'com.google.code.gson', name: 'gson', version: '2.8.2' 此处需要注意的是Spring从4.0+版本开始支持WebSocket,而servlet-api需要为3.0+版本 配置文件web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt; &lt;!-- 初始化spring 容器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring/applicationContext-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;index-dispather&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:config/spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;index-dispather&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 解决post乱码问题 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; 此处需要给servlet及filter添加异步&lt;async-supported&gt;true&lt;/async-supported&gt;. spring-mvc.xml 123456789101112131415161718192021222324252627&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 自动扫描控制器,webSocket --&gt; &lt;context:component-scan base-package="com.lhalcyon.king.controller,com.lhalcyon.king.socket"/&gt; &lt;!-- 视图渲染 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/views/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;!-- 控制器映射器和控制器适配器 --&gt; &lt;mvc:annotation-driven&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 静态资源映射器 --&gt; &lt;mvc:resources mapping="/statics/**" location="/WEB-INF/statics/" /&gt;&lt;/beans&gt; 此处需配置扫描controller和websocket所在包 还有一个applicationContext-websocket.xml配置文件我们在代码实现中说明 代码实现握手拦截器HandshakeInterceptor 拦截器说明 An interceptor to copy information from the HTTP session to the “handshakeattributes” map to made available via WebSocketSession.getAttributes()Copies a subset or all HTTP session attributes and/or the HTTP session id 拦截器主要用于用户登录标识的记录,便于后面获取指定用户的会话标识并向指定用户发送消息, 这里我们继承HttpSessionHandshakeInterceptor 123456789101112131415161718192021222324public class HandshakeInterceptor extends HttpSessionHandshakeInterceptor &#123; private Logger logger = Logger.getLogger(HandshakeInterceptor.class); // 握手前 @Override public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes) throws Exception &#123; logger.info("++ HandshakeInterceptor: beforeHandshake ++"+attributes); return super.beforeHandshake(request, response, wsHandler, attributes); &#125; // 握手后 @Override public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception ex) &#123; logger.info("++ HandshakeInterceptor: afterHandshake ++"); super.afterHandshake(request, response, wsHandler, ex); &#125;&#125; beforeHandshake(..) Invoked before the handshake is processed. afterHandshake(..) Invoked after the handshake is done. The response status and headers indicate the results of the handshake, i.e. whether it was successful or not. 两个方法调用时机均为字面所述,握手前后分别调用.主要是在握手前后去做一些事,比如将需要的数据设置到attributes里,之后在WebSocketHandler的session中获取这些数据. 处理类WebSocketHandler 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class MyWebSocketHandler implements WebSocketHandler &#123; private static final Logger log = Logger.getLogger(MyWebSocketHandler.class); // 保存所有的用户session private static final ArrayList&lt;WebSocketSession&gt; users = new ArrayList&lt;WebSocketSession&gt;(); @Override public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123; log.info("connect websocket success......."); users.add(session); &#125; @Override public void handleMessage(WebSocketSession session, WebSocketMessage&lt;?&gt; message) throws Exception &#123; Gson gson = new Gson(); // 将消息JSON格式通过Gson转换成Map // message.getPayload().toString() 获取消息具体内容 Map&lt;String, Object&gt; msg = gson.fromJson(message.getPayload().toString(), new TypeToken&lt;Map&lt;String, Object&gt;&gt;() &#123;&#125;.getType()); log.info("handleMessage......."+message.getPayload()+"..........."+msg); String content = message.getPayload().toString(); // 处理消息 msgContent消息内容 TextMessage textMessage = new TextMessage(content, true); // 调用方法（发送消息给所有人） sendMsgToAllUsers(textMessage); &#125; @Override public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception &#123; log.warn("handleTransportError"); users.remove(session); &#125; @Override public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception &#123; log.info("connect websocket closed......."); users.remove(session); &#125; // 给所有用户发送 信息 public void sendMsgToAllUsers(WebSocketMessage&lt;?&gt; message) throws Exception&#123; for (WebSocketSession user : users) &#123; user.sendMessage(message); &#125; &#125; @Override public boolean supportsPartialMessages() &#123; return false; &#125;&#125; 以下对主要方法进行说明: afterConnectionEstablished(..) 连接建立后调用,常用于记录用户的连接标识,便于后面信息发送. handleTextMessage(..) 对消息进行处理. handleTransportError(..) 连接异常处理.需要关闭出错会话连接 afterConnectionClosed(..) 连接关闭处理 此处我们对消息的处理很简单,即在接受消息后发送给所有连接的用户,类似一个匿名群聊室. 注册完成了WebSocket处理类,还需要对其进行注册生效.这里有两种方式,择其一即可. 创建配置类,并通过注解注册123456789101112131415161718192021@Configuration@EnableWebMvc@EnableWebSocketpublic class MyWebSocketConfig extends WebMvcConfigurerAdapter implements WebSocketConfigurer &#123; @Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123; //前台 可以使用websocket环境 registry.addHandler(myWebSocketHandler(),"/websocket").addInterceptors(new HandshakeInterceptor()).setAllowedOrigins("*"); //前台 不可以使用websocket环境，则使用sockjs进行模拟连接 registry.addHandler(myWebSocketHandler(), "/sockjs/websocket").addInterceptors(new HandshakeInterceptor()) .withSockJS(); &#125; // websocket 处理类 @Bean public WebSocketHandler myWebSocketHandler()&#123; return new MyWebSocketHandler(); &#125;&#125; 同时还需要配置上文提到过的Spring扫描配置类. 12&lt;!-- 自动扫描控制器,webSocket --&gt;&lt;context:component-scan base-package="com.lhalcyon.king.controller,com.lhalcyon.king.socket"/&gt; 通过xml配置注册applicationContext-websocket.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:websocket="http://www.springframework.org/schema/websocket" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/websocket http://www.springframework.org/schema/websocket/spring-websocket-4.0.xsd"&gt; &lt;!-- websocket处理类 --&gt; &lt;bean id="myHandler" class="com.lhalcyon.king.socket.MyWebSocketHandler"/&gt; &lt;!-- 握手接口/拦截器 --&gt; &lt;bean id="myInterceptor" class="com.lhalcyon.king.socket.HandshakeInterceptor"/&gt; &lt;websocket:handlers&gt; &lt;websocket:mapping path="/websocket" handler="myHandler"/&gt; &lt;websocket:handshake-interceptors&gt; &lt;ref bean="myInterceptor"/&gt; &lt;/websocket:handshake-interceptors&gt; &lt;/websocket:handlers&gt; &lt;!-- 注册 sockJS --&gt; &lt;websocket:handlers&gt; &lt;websocket:mapping path="/websocket" handler="myHandler"/&gt; &lt;websocket:handshake-interceptors&gt; &lt;ref bean="myInterceptor"/&gt; &lt;/websocket:handshake-interceptors&gt; &lt;websocket:sockjs /&gt; &lt;/websocket:handlers&gt;&lt;/beans&gt; 以上服务端代码实现基本完成,接下来对客户端测试页面做一个简单的实现. 客户端页面index.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;首页&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta name="renderer" content="webkit"&gt; &lt;!-- 引入 JQuery --&gt; &lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- 引入 sockJS --&gt; &lt;script type="text/javascript" src="https://cdn.bootcss.com/sockjs-client/1.1.4/sockjs.min.js" &gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function() &#123; var websocket; // 首先判断是否 支持 WebSocket var url = 'ws://' + window.location.host + '/word-king/websocket'; if('WebSocket' in window) &#123; websocket = new WebSocket(url); &#125; else if('MozWebSocket' in window) &#123; websocket = new MozWebSocket(url); &#125; else &#123; url = "http://"+ window.location.host +"/word-king/sockjs/websocket"; websocket = new SockJS(url); &#125; // 打开时 websocket.onopen = function(evnt) &#123; console.log(" websocket.onopen "); &#125;; // 处理消息时 websocket.onmessage = function(evnt) &#123; $("#msg").append("&lt;p&gt;(&lt;font color='red'&gt;" + evnt.data + "&lt;/font&gt;)&lt;/p&gt;"); console.log(" websocket.onmessage "); &#125;; websocket.onerror = function(evnt) &#123; alert("onerror"); console.log(" websocket.onerror "); &#125;; websocket.onclose = function(evnt) &#123; console.log(" websocket.onclose "); alert("onclose"); &#125;; // 点击了发送消息按钮的响应事件 $("#TXBTN").click(function()&#123; // 获取消息内容 var text = $("#tx").val(); // 判断 if(text == null || text == "")&#123; alert(" content can not empty!!"); return false; &#125; var msg = &#123; msgContent: text, postsId: 1 &#125;; // 发送消息 websocket.send(JSON.stringify(msg)); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 最外边框 --&gt;&lt;div style="margin: 20px auto; border: 1px solid blue; width: 300px; height: 500px;"&gt; &lt;!-- 消息展示框 --&gt; &lt;div id="msg" style="width: 100%; height: 70%; border: 1px solid yellow;overflow: auto;"&gt;&lt;/div&gt; &lt;!-- 消息编辑框 --&gt; &lt;textarea id="tx" style="width: 100%; height: 20%;"&gt;&lt;/textarea&gt; &lt;!-- 消息发送按钮 --&gt; &lt;button id="TXBTN" style="width: 100%; height: 8%;"&gt;发送数据&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 需要注意的是此处引入JQuery时,如果是本地的文件,可能存在无效的情况,需要去设置静态资源映射路径,可自行🔍解决. 本文采用的是引入在线地址 12&lt;!-- 引入 JQuery --&gt; &lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.5/jquery.min.js"&gt;&lt;/script&gt; 地址写入后需Download下来 代码不高亮警告后即能生效. 最后我们来看看效果 参考: http://blog.csdn.net/mybook201314/article/details/70173674]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>WebSocket</tag>
        <tag>IM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现apk上传蒲公英后自动发送钉钉通知]]></title>
    <url>%2Fwebhook_dingding-pgyer%2F</url>
    <content type="text"><![CDATA[Webhook是一个API概念，并且变得越来越流行。我们能用事件描述的事物越多，webhook的作用范围也就越大。Webhook作为一个轻量的事件处理应用，正变得越来越有用。 准确的说webhook是一种web回调或者http的push API，是向APP或者其他应用提供实时信息的一种方式。Webhook在数据产生时立即发送数据，也就是你能实时收到数据。这一种不同于典型的API，需要用了实时性需要足够快的轮询。这无论是对生产还是对消费者都是高效的，唯一的缺点是初始建立困难。 Webhook有时也被称为反向API，因为他提供了API规则，你需要设计要使用的API。Webhook将向你的应用发起http请求，典型的是post请求，应用程序由请求驱动。 在Android开发中会经常提交apk给测试人员进行测试,通常的做法是将构建完成的包上传至蒲公英,测试人员直接扫码下载并安装apk包从而进行测试.一般我们会将构建及发布过程自动化,可参考: Linux+Jenkins+Gradle构建Android参数化自动打包(一) Linux+Jenkins+Gradle构建Android参数化自动打包(二) 文章中实现了apk上传蒲公英后邮件通知,可是实际中,大家对邮件的关注远远没有对IM消息的关注度高,所以接下来本文将说明,实现上传apk后自动发送钉钉消息,将更新内容,apk版本号等信息通知到测试人员 环境准备首先环境搭建是IntelliJ+SpringMVC+Gradle构建的,如有疑问的同学可参考IDEA+Gradle创建MyBatis+SpringMVC项目,项目中主要是对接口数据的调整及转发,实际上未用到MyBatis,可自行进行去除🙄. 模型建立对照蒲公英doc、钉钉doc分别建立Java Bean. PgyerMessage 123456789101112131415&#123; "action": "应用更新", "title": "OooPlay", "link": "https://www.pgyer.com/oooplay_test", "message": "您的应用OooPlay有了新的版本(2.4)更新。", "type": "updateVersion", "os_version": "2.4", "build_version": "139", "created": "2015-10-09 11:25:16", "updated": "2015-10-09 11:25:16", "timestamp": 1444361118, "appsize": "2238036", "device_type": 'iOS', "notes": "修复了一些小弱智的小bug"&#125; 1234567891011121314151617181920212223242526272829303132333435public class PgyerMessage &#123; public String action; public String title; public String link; public String message; public String type; public String os_version; public String build_version; public String created; public String updated; public int timestamp; public String appsize; public String device_type; public String notes; @Override public String toString() &#123; return "PgyerMessage&#123;" + "action='" + action + '\'' + ", title='" + title + '\'' + ", link='" + link + '\'' + ", message='" + message + '\'' + ", type='" + type + '\'' + ", os_version='" + os_version + '\'' + ", build_version='" + build_version + '\'' + ", created='" + created + '\'' + ", updated='" + updated + '\'' + ", timestamp=" + timestamp + ", appsize='" + appsize + '\'' + ", device_type='" + device_type + '\'' + ", notes='" + notes + '\'' + '&#125;'; &#125;&#125; 此处有个小技巧,IDEA IntelliJ有个好用的插件GsonFormat可一键将Json字符串转换为Java Model 钉钉消息则分为几种类型,具体举例可参考钉钉doc 123456789public static final String TYPE_LINK = "link";public static final String TYPE_MARKDOWN = "markdown";public static final String TYPE_TEXT = "text";public static final String TYPE_ACTIONCARD = "actionCard";public static final String TYPE_FEEDCARD = "feedCard"; 此处我们选择markdown类型.为了便于拓展,此处将消息抽取了个基类BaseDingMessage. 123456789101112131415161718192021public class BaseDingMessage &#123; public static final String TYPE_LINK = "link"; public static final String TYPE_MARKDOWN = "markdown"; public static final String TYPE_TEXT = "text"; public static final String TYPE_ACTIONCARD = "actionCard"; public static final String TYPE_FEEDCARD = "feedCard"; public String msgtype; public AtBean at; public static class AtBean &#123; public boolean isAtAll; public List&lt;String&gt; atMobiles; &#125;&#125; 12345678910public class MarkdownMessage extends BaseDingMessage &#123; public MarkdownBean markdown; public static class MarkdownBean &#123; public String title; public String text; &#125;&#125; 代码实现首先在build.gradle中导入依赖 12compile group: 'com.alibaba', name: 'fastjson', version: '1.2.45'compile group: 'com.squareup.okhttp3', name: 'okhttp', version: '3.9.0' fastjson是用力啊转化json,okhttp用来网络请求 spring-mvc.xml加入json配置 12345678910111213141516171819202122232425262728293031323334353637&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 自动扫描控制器 --&gt; &lt;context:component-scan base-package="com.lhalcyon.webhook.controller"/&gt; &lt;!-- 视图渲染 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/views/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;!-- 控制器映射器和控制器适配器 --&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults="true"&gt; &lt;bean class="com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;value&gt;application/json&lt;/value&gt; &lt;value&gt;application/xml;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 静态资源映射器 --&gt; &lt;mvc:resources mapping="/statics/**" location="/WEB-INF/statics/" /&gt;&lt;/beans&gt; 消息发送服务DingServiceImpl.java 123456789101112131415161718192021Servicepublic class DingServiceImpl implements DingService &#123; private static final Logger logger = Logger.getLogger(DingServiceImpl.class); @Override public void send(BaseDingMessage message,String url) &#123; MediaType jsonType = MediaType.parse("application/json; charset=utf-8"); okhttp3.RequestBody body = okhttp3.RequestBody.create(jsonType, JSON.toJSONString(message)); final Request request = new Request.Builder() .url(url) .post(body) .build(); OkHttpClient client = OkhttpProvider.get(); try &#123; client.newCall(request).execute(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 蒲公英请求控制器PgyerController.java 123456789101112131415161718@RestController@RequestMapping("/pgyer")public class PgyerController &#123; @Autowired DingService dingService; private static final Logger logger = Logger.getLogger(PgyerController.class); @ResponseBody @RequestMapping(value = "/update",method = RequestMethod.POST) public BaseDingMessage apkUpdate(@RequestBody PgyerMessage pgyerMessage)&#123; BaseDingMessage dingMessage = WebhookConverter.pgyer2Ding(pgyerMessage); dingService.send(dingMessage, Urls.DING_TEST); logger.info(dingMessage); return dingMessage; &#125;&#125; 其中Urls.DING_TEST为钉钉机器人的会话token地址,后面会说明如何创建/获取 消息转换器WebhookConverter.java 123456789101112131415161718192021222324public class WebhookConverter &#123; private static final Logger logger = Logger.getLogger(WebhookConverter.class); public static MarkdownMessage pgyer2Ding(PgyerMessage pgyerMessage)&#123; MarkdownMessage message = new MarkdownMessage(); message.msgtype = BaseDingMessage.TYPE_MARKDOWN; message.markdown = new MarkdownMessage.MarkdownBean(); message.markdown.title = pgyerMessage.device_type + "蒲公英更新"; StringBuilder builder = new StringBuilder(); builder.append("#### ").append(pgyerMessage.device_type).append("测试包已更新! \n\n") .append("###### version: ").append(pgyerMessage.os_version).append(" | build ").append(pgyerMessage.build_version).append("\n\n") .append("更新内容:\n").append("&gt; ").append(pgyerMessage.notes).append("\n\n") .append("![qr_code_test](图片地址)\n\n") .append("[下载地址](https://www.pgyer.com/你的apk地址) 密码:你的密码\n").append(" @18810100000 @18810100001 @18818100002 "); message.markdown.text = builder.toString(); message.at = new BaseDingMessage.AtBean(); message.at.isAtAll = false; message.at.atMobiles = Arrays.asList("18818100000","18818100001","18818100002"); return message; &#125;&#125; 以上需自行修改内容. 然后创建钉钉机器人.创建四连 1 2 3 4 点此复制钉钉机器人会话token,建立Urls.java. 1234567public interface Urls &#123; /** * 提测群机器人token */ String DING_TEST = "钉钉token";&#125; 此处的Ding_Test即为上面复制的地址 至此,代码主要实现类已经完成,接下来需要去配置蒲公英webhook 配置webhook打开蒲公英应用设置 创建webhook,写入PgyerController的更新请求地址,如果配置与本文的相同,地址则为 1http://你的地址:端口/webhook-1.0-SNAPSHOT/pgyer/update 其中webhook-1.0-SNAPSHOT为war包在tomcat解压后的名称 done! 之后只要上传成功后,即有钉钉消息通知并@测试人员了! 让我们再看下打包后的消息通知! 类似的,代码push,merge也可以做成webhook消息. Github、Gitlab既有成熟的对接机器人.而笔者使用的Coding是没有与钉钉做对接的,此时可自定义机器人实现,有兴趣的同学可参考上面的教程自行实现.]]></content>
      <categories>
        <category>Webhook</category>
      </categories>
      <tags>
        <tag>Dingding</tag>
        <tag>Webhook</tag>
        <tag>Pgyer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux升级Glibc2.14中文乱码]]></title>
    <url>%2Fupdate_glibc_issue%2F</url>
    <content type="text"><![CDATA[CenterOS上默认的Glibc版本为2.12.1,由于我们的Android项目使用到了JNI,将项目构建部署在服务器上时会遇到问题&#39;GLIBC_2.14&#39; not found,那么就需要升级Glibc至2.14.升级的教程网上很多,可是却漏掉了一个步骤,导致后面中文乱码的问题.本篇会做一个全面的解说 1. Glibc下载首先从Glibc Download下载包,这里选择是Glibc 2.14 2. 安装上传至服务器,进入目录解压 1tar zxvf glibc-2.14.tar.gz 进入解压后的目录 1cd glibc-2.14 接着 12345mkdir /opt/buildcd build../configure --prefix=/opt/glibc-2.14make -j4make install 若顺利的话,至此则安装成功了. issue1. 在make install过程中出现错误: 1Can&apos;t open configuration file /opt/glibc-2.14/etc/ld.so.conf: No such file or directory 缺少了报错的编译文件ld.so.conf.通过find命令找到对应的文件配置 然后拷贝文件至对应文件目录,继续编译 12cp /etc/ld.so.conf /opt/glibc-2.14/etc/ make install 编译成功,接着定义下环境变量即可 3. 补充通常的教程至此就结束了.最初笔者参考网上的教程也是做到这里.当时跑程序也没问题,直到前段时间大楼停电,服务器重启后,通过服务器上Jenkins打包上传到蒲公英的中文信息全是乱码! 相当于服务器的编码文件丢失了,所有中文都会乱码. 是因为遗漏了localedata未编译,在服务器重启后,Glibc2.14找不到对应版本2.14的glibc locale文件. 正确操作是,在make&amp;make install完成后继续编译local包 1make localedata/install-locales 编译需要一些时间,完成后重启服务器即可生效 1shutdown -r now 参考: http://blog.csdn.net/clirus/article/details/62425498 参考: http://blog.csdn.net/fzuzhanghao1993/article/details/77650500]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA+Gradle创建MyBatis+SpringMVC项目]]></title>
    <url>%2Fssm_build%2F</url>
    <content type="text"><![CDATA[Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建工具.它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置,抛弃了基于XML的各种繁琐配置. IDEA 全称IntelliJ IDEA,是java语言开发的集成环境,IntelliJ在业界被公认为最好的java开发工具之一,尤其在智能代码助手、代码自动提示、重构、J2EE支持、Ant、JUnit、CVS整合、代码审查、 创新的GUI设计等方面的功能可以说是超常的. 以上为百度的简介.从事Android的童鞋应该不难发现Gradle以及Android Studio的强(hen)大(ka).🤫而AS是基于IntelliJ IDEA开发的.习惯了Gradle的便捷,于是开始基于Gradle+IDEA构建Java项目. 环境准备1. 数据库MySql在MySql Downloads下载对应的版本并安装 此处笔者在macOS上安装5.7.21后打开系统偏好设置,遇到无法加载MySql面板的问题.一番搜索🔍后发现是macOS版本与MySql不兼容,选择低版本的MySql如5.6.39即可. 2. IntelliJ IDEA请自行安(po)装(jie). 3. Tomcat请自行下载解压.如若是macOS或是Linux上解压后需进入bin目录执行下命令chmod u+x *.sh修改权限 创建项目点击 Create New Project 选择基于Gradle的Java Web项目 填写GroupId和ArtifactId 选择gradle.可使用默认的,可使用本地的 接着选择项目目录,基本项目创建好了,接下来进入文件配置 文件配置首先创建java和resources目录,并且创建包以及web.xml. log4j.properties12345678910111213141516171819#设置日志的级别，定义日志信息的输出目的log4j.rootLogger=DEBUG, A1 ,R#定义A1的输出目的地为控制台log4j.appender.A1=org.apache.log4j.ConsoleAppender#布局为 PatternLayout 可以灵活地指定布局模式。log4j.appender.A1.layout=org.apache.log4j.PatternLayout#设置输出格式log4j.appender.A1.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH\:mm\:ss&#125; [%c]-[%p] %m%n#定义R的输出目的地为文件，并且文件大小到达指定尺寸的时候产生一个新的文件log4j.appender.R=org.apache.log4j.RollingFileAppender#设置输出的文件地址log4j.appender.R.File=/Users/xx/Documents/ServerLog#设置文件大小伟100 kb 文件到达100时，产生一个新文件，#MaxBackupIndex 最大记录的文件数为1 查过一个文件删除文件较早的。log4j.appender.R.MaxFileSize=100KB log4j.appender.R.MaxBackupIndex=1#以下和上面一样log4j.appender.R.layout=org.apache.log4j.PatternLayoutlog4j.appender.R.layout.ConversionPattern=%p %t %c - %m%n 以上输出文件地址自行更改 generatorConfig.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;classPathEntry location="$&#123;jarDirection&#125;"/&gt; &lt;context id="mysql" targetRuntime="MyBatis3"&gt; &lt;jdbcConnection driverClass="$&#123;driverClass&#125;" connectionURL="$&#123;connectionURL&#125;" userId="$&#123;userId&#125;" password="$&#123;password&#125;"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver &gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;javaModelGenerator targetPackage="$&#123;modelPackage&#125;" targetProject="$&#123;src_main_java&#125;"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage="$&#123;sqlMapperPackage&#125;" targetProject="$&#123;src_main_java&#125;"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/sqlMapGenerator&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="$&#123;mapperPackage&#125;" targetProject="$&#123;src_main_java&#125;"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 每一个数据库表都对应一个对应的table属性 --&gt; &lt;table tableName="book" domainObjectName="Book"&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; gradle.properties123456# 生成的model类所在包modelPackage=com.lhalcyon.webhook.domain# 生成的mapper接口类所在包mapperPackage=com.lhalcyon.webhook.mapper# 生成的mapper xml文件所在包sqlMapperPackage=com.lhalcyon.webhook.mapper 为了方便扫描,将mapper xml以及接口类放在了同一包下了 😕 jdbc-mysql.properties12345678910# 将jdbc.jarDirection后的内容更改为gradle下载的# mysql-connector-java-5.1.x.jar所在的路径，gradle自动下载的路径如下所示jdbc.jarDirection=/Users/ceyx/.gradle/caches/modules-2/files-2.1/mysql/mysql-connector-java/5.1.38/dbbd7cd309ce167ec8367de4e41c63c2c8593cc5/mysql-connector-java-5.1.38.jarjdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/halcyonjdbc.user=rootjdbc.pass=root 自行填写jdbc.jarDirection路径 build.gradle123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596group 'com.lhalcyon'version '1.0-SNAPSHOT'apply plugin: 'java'apply plugin: 'war'sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;configurations &#123; mybatisGenerator&#125;// 读取config文件夹中对应的配置文件ext&#123; def prop = new Properties(); file("src/main/resources/config/mybatis/jdbc-mysql.properties") .withInputStream &#123; prop.load(it) &#125; file("src/main/resources/config/mybatis/gradle.properties") .withInputStream &#123; prop.load(it) &#125; prop.each &#123; project.extensions.add("$it.key",it.value); &#125;&#125;dependencies &#123; testCompile group: 'junit', name: 'junit', version: '4.12' compile 'org.codehaus.groovy:groovy-all:2.3.11' compile 'jstl:jstl:1.2' compile 'org.springframework:spring-aop:4.2.4.RELEASE' compile 'org.springframework:spring-context:4.2.4.RELEASE' compile 'org.springframework:spring-beans:4.2.4.RELEASE' compile 'org.springframework:spring-web:4.2.4.RELEASE' compile 'org.springframework:spring-webmvc:4.2.4.RELEASE' compile 'org.springframework:spring-tx:4.2.4.RELEASE' compile 'org.springframework:spring-jdbc:4.2.4.RELEASE' compile 'org.springframework:spring-test:4.2.4.RELEASE' compile 'mysql:mysql-connector-java:5.1.38' compile 'org.mybatis.generator:mybatis-generator-core:1.3.2' compile 'org.mybatis:mybatis-spring:1.2.3' compile 'org.mybatis:mybatis:3.3.0' compile 'junit:junit:4.12' compile group: 'commons-dbcp', name: 'commons-dbcp', version: '1.4' compile group: 'org.aspectj', name: 'aspectjweaver', version: '1.8.13' compile group: 'log4j', name: 'log4j', version: '1.2.17' mybatisGenerator 'org.mybatis.generator:mybatis-generator-core:1.3.2' mybatisGenerator 'mysql:mysql-connector-java:5.1.38'&#125;// 利用ant创建一个自动生成MyBatis目录文件的tasktask mybatisGenerate &lt;&lt; &#123; ant.properties['targetProject'] = projectDir.path ant.properties['jarDirection'] = project['jdbc.jarDirection'] ant.properties['driverClass'] = project['jdbc.driverClassName'] ant.properties['connectionURL'] = project['jdbc.url'] ant.properties['userId'] = project['jdbc.user'] ant.properties['password'] = project['jdbc.pass'] ant.properties['src_main_java'] = sourceSets.main.java.srcDirs[0].path ant.properties['src_main_resources'] = sourceSets.main.resources.srcDirs[0].path ant.properties['modelPackage'] = project['modelPackage'] ant.properties['mapperPackage'] = project['mapperPackage'] ant.properties['sqlMapperPackage'] = project['sqlMapperPackage'] ant.taskdef( name: 'mbgenerator', classname: 'org.mybatis.generator.ant.GeneratorAntTask', classpath: configurations.mybatisGenerator.asPath ) ant.mbgenerator(overwrite: true, configfile: 'src/main/resources/config/mybatis/generatorConfig.xml', verbose: true) &#123; propertyset &#123; propertyref(name: 'targetProject') propertyref(name: 'jarDirection') propertyref(name: 'userId') propertyref(name: 'driverClass') propertyref(name: 'connectionURL') propertyref(name: 'password') propertyref(name: 'src_main_java') propertyref(name: 'src_main_resources') propertyref(name: 'modelPackage') propertyref(name: 'mapperPackage') propertyref(name: 'sqlMapperPackage') &#125; &#125;&#125; 接着Sync或者点击Import Changes IDEA就会下载依赖包了.依赖版本号均源于Maven Repository spring-mvc.xml 导入依赖后,则可直接创建spring相关xml 123456789101112131415161718192021222324&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 自动扫描控制器 --&gt; &lt;context:component-scan base-package="com.lhalcyon.webhook.controller"/&gt; &lt;!-- 视图渲染 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/views/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;!-- 控制器映射器和控制器适配器 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源映射器 --&gt; &lt;mvc:resources mapping="/statics/**" location="/WEB-INF/statics/" /&gt;&lt;/beans&gt; applicationContext-dao.xml123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 加载配置文件 --&gt; &lt;context:property-placeholder location="classpath:config/mybatis/jdbc-mysql.properties" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.user&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.pass&#125;" /&gt; &lt;property name="maxActive" value="10" /&gt; &lt;property name="maxIdle" value="5" /&gt; &lt;/bean&gt; &lt;!-- mapper配置 --&gt; &lt;!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;!--&lt;property name="mapperLocations" value="classpath*:com/lhalcyon/mapper/*.xml"/&gt;--&gt; &lt;/bean&gt; &lt;!-- 配置Mapper扫描器 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.lhalcyon.webhook.mapper"/&gt; &lt;/bean&gt;&lt;/beans&gt; applicationContext-service.xml1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 配置包扫描器 --&gt; &lt;context:component-scan base-package="com.lhalcyon.webhook.service"/&gt;&lt;/beans&gt; applicationContext-trans.xml1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 数据源 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:method name="insert*" propagation="REQUIRED" /&gt; &lt;tx:method name="delete*" propagation="REQUIRED" /&gt; &lt;tx:method name="update*" propagation="REQUIRED" /&gt; &lt;tx:method name="query*" propagation="SUPPORTS" read-only="true" /&gt; &lt;tx:method name="get*" propagation="SUPPORTS" read-only="true" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 切面 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* com.lhalcyon.webhook.service.*.*(..))" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt; &lt;!-- 初始化spring 容器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring/applicationContext-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;index-dispather&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:config/spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;index-dispather&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 解决post乱码问题 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; Tomcat部署Run-&gt;Edit Configurations 有fix项点击配置即可,然后运行. MyBatis配置数据库管理工具笔者使用的是 首先创建数据库halcyon,接着创建book表,用于后面的mybatis generator 12345CREATE TABLE book ( book_id INT PRIMARY KEY AUTO_INCREMENT, book_name VARCHAR(30) NOT NULL, author VARCHAR(20) default '佚名') 然后在gradle创建mybatis generator task 运行task 运行成功后,会生成与数据库表对应的java bean与dao文件,即项目里的Book.java、BookExample.java、BookMapper.xml、BookMapper.java generatorConfig.xml配置参数可自行搜索补充修改🤔.手动覆写下Book的toString方法方便日志输出 测试为了满足同时测试Spring、SpringMVC、Mybatis,笔者建立一个Controller通过Get请求进行CURD操作. Service1234567891011121314151617181920212223242526272829@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired private BookMapper bookMapper; @Override public void insertBook(Book book) &#123; bookMapper.insert(book); &#125; @Override public void updateBook(Book book) &#123; bookMapper.updateByPrimaryKey(book); &#125; @Override public List&lt;Book&gt; getAllBooks() &#123; BookExample example = new BookExample(); return bookMapper.selectByExample(example); &#125; @Override public void deleteBookById(int bookId) &#123; BookExample example = new BookExample(); example.createCriteria().andBookIdEqualTo(bookId); bookMapper.deleteByExample(example); &#125;&#125; Controller1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@RestControllerpublic class BookController &#123; private static final Logger logger = Logger.getLogger(BookController.class); @Autowired private BookService bookService; @RequestMapping(value = "/insert",method = RequestMethod.GET) public String insert(String bookName,String author)&#123; Book book = new Book(); book.setBookName(bookName); book.setAuthor(author); bookService.insertBook(book); return queryStrings(); &#125; @RequestMapping("/update") public String updateAuthor(int bookId,String bookName,String author)&#123; Book book = new Book(); book.setBookId(bookId); book.setBookName(bookName); book.setAuthor(author); bookService.updateBook(book); return queryStrings(); &#125; @RequestMapping("/delete") public String deleteBook(int bookId)&#123; bookService.deleteBookById(bookId); return queryStrings(); &#125; @RequestMapping("/find_all") public String getAllBooks()&#123; List&lt;Book&gt; books = bookService.getAllBooks(); logger.info(books); return books.toString(); &#125; private String queryStrings()&#123; List&lt;Book&gt; allBooks = bookService.getAllBooks(); return allBooks.toString(); &#125;&#125; 直接通过请求地址,获得结果 插入: 1http://localhost:8080/webhook/insert?bookName=java&amp;author=jack 执行后直接将数据库中所有book记录输出,方便观察. 其它操作类似 更新: 1http://localhost:8080/webhook/update?bookId=3&amp;bookName=go&amp;author=joe 删除: 1http://localhost:8080/webhook/delete?bookId=4 查询(所有): 1http://localhost:8080/webhook/find_all 如若发生500 Invalid bound statement (not found)类似错误,一般是没有扫描到Mapper.xml.其中一种情况下是xml根本没被打包进war.需要在build.gradle中进行配置,并且配置后Sync或Import Changes,再重新用命令./gradlew build才可生效. 123456//将src文件夹中的资源文件同时打包processResources &#123; from(&apos;src/main/java&apos;) &#123; include &apos;**/*.xml&apos; &#125;&#125; 至此SpringMVC+MyBatis+Gradle项目已经构建测试完毕. 代码已上传GayHub,文章若对各位大佬有帮助,麻烦顺手点个star~ ❤️ 各位可能发现了,SSM配置起来比较繁琐,相比之下,SpringBoot就精简了许多.后面有机会,我们再来细说 🤒 参考: https://www.cnblogs.com/bojuetech/p/5844413.html 参考: http://blog.csdn.net/kingboyworld/article/details/78251425]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IntelliJ</tag>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio版本兼容Api警告]]></title>
    <url>%2Fas_warning%2F</url>
    <content type="text"><![CDATA[Android Studio版本兼容Api警告最近在开发中,组内的小伙伴在开发中使用了高版本SDK25的Api,但是我们的项目最低兼容14,因此测试在5.1上的手机直接就崩溃了,问其在开发中没有看到警告吗,回复说确实没看到.后来查究一下,他的工具上确实没有显示.本文简述下如何手动去调整兼容Api的提示等级,避免在开发中用到高版本的Api却不自察. 首先win电脑是打开Android Studio的 Setting ,mac是打开Android Studio的 Preferences 选择Editor中的Inspections 对Calling new methods on older versions进行勾选并且配置为Error级别 如此简单即可搞定.如遇到其他警告,错误代码没提示也可类似进行操作配置.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode代码提示问题处理]]></title>
    <url>%2Fxcode-idiot%2F</url>
    <content type="text"><![CDATA[最近在写Swift.对于笔者这种被JetBrains的几大IDE工具给惯坏的开发者,Xcode的代码提示真是无力吐槽,先不论智能提示度,就连基本的提示也经常出不来.这里就简单总结下iOS同事传授的几招解决办法 1.Clean Project最直接的办法就是清空项目. 可视化按钮入口再哪请自行查找,笔者一般是用Command+Shift+K进行清空,此方法一般有效,缺点是会重新编译项目,比较慢 2.清空Xcode缓存前往Xcode的缓存目录,清空项目编译缓存. 具体操作为右键Finder前往文件夹文件夹路径为/用户/ceyx/资源库/Developer/Xcode/DerivedData 其中ceyx 替换为自己的用户名,删除目录下所有文件,然后重新打开Xcode,编译. 此方法比1更慢,往往也更有效 3.终极大招如若上述两种方法还无效,只能使用绝招了…重启Xcode,还不行就重启电脑… 笔者黔驴技穷了,只能充当下网吧老板传授下终极大招.👻 题外话,对于JetBrains出品的appcode还未尝试过,不知对于Xcode项目兼容到何程度,是否支持Cocoapod等,有时间会去体验下,希望至少在代码提示上能更友善些😀 笔者去体验了下Appcode,其代码提示和快捷键如Jetbrains其他产品一样非常智能,但是代码中偶有飘红,却可以成功运行,比较干扰编码.尤为尴尬的一点是,Appcode不支持storyboard,即在项目内点开storyboard文件就直接跳转xcode了😥. 如真的被Xcode逼疯的童鞋可以考虑下用AppCode编码,用Xcode操作storyboard]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux+Jenkins+Gradle构建Android参数化自动打包(二)]]></title>
    <url>%2Flinux-jenkins-gradle_build_android2%2F</url>
    <content type="text"><![CDATA[在前一篇文章中,说明了在CenterOS上进行一系列的环境搭建,本文开始说明关于项目的一系列配置 Jenkins项目配置首先创建一个项目,将构建保持的天数和个数进行限制 此处感谢后台同事提示,因为Android SDK NDK 就特别占空间了,如果构建缓存不进行限制,则很快服务器空间就会不足🤥 参数构建配置打包环境 分支指定 email自定义接收者 打包时间戳 因为笔者的公司对打包的Apk名以及测试版本号时间戳显示的要求,因此需要使用动态参数 还有其他参数均与以上类似,可自行配置 !!! 记住尤为重要的是这些参数都是Jenkins上配置的Gradle属性,得传递到App的Gradle中 这里勾选Pass all job parameters as Project properties 源码管理在源码管理处配置Git账号 这里的*/${BRANCH}对应参数配置时的BRANCH.为什么这里做成选择型参数呢,是因为分支名是未知的,做成填写的话,可能压根拉不到指定分支的代码🤐 Gradle构建脚本增加构建动作 这里${WORKSPACE}指的是Git拉下的根目录.途中马赛克位置则为项目根目录 蒲公英上传增加构建动作,将Apk上传蒲公英 1curl -k -F &quot;file=@$&#123;WORKSPACE&#125;/source/项目根目录/app/apks/$&#123;BUILD_PREFIX&#125;_$&#123;JENKINS_TIME&#125;_$&#123;DAY_VERSION&#125;.apk&quot; -F &quot;uKey=你的ukey&quot; -F &quot;_api_key=你的apiKey&quot; -F &quot;installType=2&quot; -F &quot;password=下载密码&quot; -F &quot;updateDescription=$&#123;DESCRIPTION&#125;&quot; https://www.pgyer.com/apiv1/app/upload ${WORKSPACE}/source/项目根目录/app/apks/为笔者自行修改的Apk输出目录,此处请根据自己的项目输入目录进行修改 curl命令如果使用不了可自行百度解决 以下为蒲公英的上传Api,可以自行调整参数 邮件通知首先还是进入Jenkins-&gt;系统设置 在Jenkins Location中进行配置 Jenkins URL:http://10.50.0.16:8777/jenkins/ 系统管理员邮件地址: Android参数化构建&lt;aaa@163.com&gt; 此处Android参数化构建就为邮件中的发送人名称 系统设置中的默认收件人最好不要配置为自己,因为如果配置后,自己就永远在收件人的前端,后面想发送给领导时,便不大好. 邮件的内容可自定义html内容,二维码直接线下生成蒲公英的地址然后贴在邮件内即可 App本地Gradle配置首先在gradle.properties文件中进行参数化构建在非Jenkins写入情况时的缺省值配置 在未使用Jenkins构建的情况下应用会读本地的这些变量值 然后在appmodule下的build.gradle中进行配置写入的值配置 12345678910111213141516171819202122232425262728293031323334//修改生成的apk名字及输出目录applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def newName def oldFile = output.outputFile def outDirectory = oldFile.parent def buildPrefix def showVersion if (variant.buildType.name == &apos;debug&apos;) &#123; buildPrefix = BUILD_PREFIX &#125; else &#123; buildPrefix = BUILD_PREFIX_RELEASE &#125; def jenkinsTime = JENKINS_TIME if (variant.buildType.name == &apos;debug&apos;) &#123; showVersion = buildPrefix + &apos;_&apos; + jenkinsTime + &apos;_&apos; + DAY_VERSION &#125; else &#123; showVersion = APP_VERSION &#125; resValue(&quot;string&quot;, &apos;fund_app_version&apos;, showVersion) def tempFile = file(&quot;build.gradle&quot;) outDirectory = tempFile.parent + &apos;/apks&apos; if (IS_JENKINS) &#123; newName = buildPrefix + &apos;_&apos; + jenkinsTime + &apos;_&apos; + DAY_VERSION + &apos;.apk&apos; &#125; else &#123; newName = &apos;android-v&apos; + APP_VERSION + &apos;-&apos; + variant.productFlavors[0].name + &apos;-&apos; + variant.buildType.name + &apos;.apk&apos; &#125; output.outputFile = new File(outDirectory, newName) &#125;&#125; 系统默认的输入路径是在build文件夹中,层级比较深.此处笔者将apk的输出路径进行了修改并且对apk的输出名称进行了调整 至此,Jenkins参数自动化构建已经完成!😀]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>Android</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux+Jenkins+Gradle构建Android参数化自动打包(一)]]></title>
    <url>%2Flinux-jenkins-gradle_build_android1%2F</url>
    <content type="text"><![CDATA[前言关于Jenkins部署安卓自动打包有很多好处,可以配置参数进行构建,选择打包环境、设置App版本、设置加密开关等.起初,笔者也是参考了一些网上的教程,将自动化打包构建在了自己的windows开发机器上,而将Jenkins自动构建Android部署在服务器上和本机上在环境构建方面略有不同,坑略多. 参数化构建的过程却是很便捷,但是部署在本机上自动化打包其实是个会增加打包时长的工作,因为自动化打包会首先去代码仓库拉取代码到本地,然后再开始打包,这个过程会比直接用AS打包慢很多.后来提出需求,要将自动化打包配置到服务器上.运维就提供了一台Linux服务器,并且上面已配置后台的自动化打包环境,用的是Jdk1.7和比较旧版本的Jenkins,于是我们得另行使用独立的安装的环境. 最终结果最终我们要实现的是实现Jenkins上面配置应用版本号、Git分支、应用渠道、请求基地址、应用环境等参数,进行一键参数化构建打包上传至蒲公英并发送邮件通知给自定义的接收者 最终实现参数化配置大致如下所示: 发送邮件(邮件内容较长,进行了相应缩小) 环境搭建所需环境 新版Jenkins(需能安装参数化构建插件) Tomcat 新版Jenkins Android SDK Android NDK aapt Git Gradle 其它(视自身项目所需) CenterOS64位已有环境 Jdk1.7 Tomcat 旧版Jenkins 1. Jdk安装及配置由于Android开发使用的 Jdk1.8,因此不能复用服务器上现有的Jdk 首先去Oracle Downloads下载 Jdk for Linux.笔者下载的是jdk-8u131-linux-x64.tar.gz 上传到服务器,进入相关目录解压 1tar -zxvf jdk-8u131-linux-x64.tar.gz 可将目录移至其他目录.其实最好在解压前就将压缩包移至目标目录 Jdk环境变量配置(可选) 由于后台使用了JAVA_HOME、JENKINS_HOME等一系列环境变量名,所以服务器上默认调用的会是他们的环境变量,我们开发的一套只能在自己的Tomcat、Jenkins中进行指定,具体下文会进行说明 2. Tomcat安装及配置首先去Tomcat Download选择版本进行下载.这里笔者选择的是apache-tomcat-7.0.79.tar.gz 上传到服务器,进入相关目录解压 1tar -zxv -f apache-tomcat-7.0.79.tar.gz a.端口修改由于常规tomcat端口被已有tomcat占用,因此我们需要修改端口 进入conf目录下的server.xml修改,此处笔者是用Vim修改.不会用的同学请出门左转度娘🤔 主要修改的是,设置为自定义端口号 Tomcat admin port 即文件最上面的端口号 Http/1.1 port 连接访问的端口号 AJP/1.3 port b.环境配置指定Tomcat运行时环境,在bin目录下修改setclasspath.sh 以下是笔者的环境,请自行替换路径 123export JAVA_HOME=/usr/android/java/jdk1.8.0_131export JRE_HOME=/usr/android/java/jdk1.8.0_131/jreexport JENKINS_HOME=/home/android/jenkins 3. Gradle安装及配置首先去Gradle Download下载对应Gradle版本,笔者使用到的是gradle-3.3-all.zip 上传到指定目录解压 1unzip gradle-3.3-all.zip 然后添加环境变量vim /etc/profile,在环境变量配置处增加一句 1export GRADLE_HOME=/home/gradle-3.3/bin 4. Android Sdk For Linux 安装及更新这里下载Sdk解压都不是难点.难点在于安装之后更新的问题. 用AS或者Eclipse的同学肯定接触过Sdk Manager,此处选择更新后要手动点Accept License才能启动更新.但是在Linux下没有界面化的勾选可用.因此需要用脚本来更新.网上有说复制License的方法笔者试了无效,也许是姿势不对吧,此处也是踩了很久的坑才搜出来的解决方法: 更新Sdk方法传送门 这里先感谢下该作者👏 这里也为不愿跳传送门的同学说明一下,就几个步骤. a.查看可更新列表 在Sdk的tools目录使用./android list sdk --all查看远程服务器提供的Sdk包的序号,记录想要更新的Sdk序号 b.编辑脚本 1234567#!/usr/bin/expectset timeout -1spawn /usr/local/android-sdk-linux/tools/android update sdk -u -a -t 1,2,3,24,25,26,27,28,30,95,96,102,103,104,105,106,107expect &#123; &quot;Do you accept the license&quot; &#123; exp_send &quot;y\r&quot; ; exp_continue &#125; eof&#125; 此处1,2,3,...为需要下载的Sdk序号 c.运行脚本 待脚本跑完,sdk就更新完毕了 注意此处脚本用到了expect,需要在服务器上安装,此处提供expect安装传送门 5. Ndk for Linux安装安装较简单,后续需配置Jenkins系统变量,下文会进行说明 项目因用到了Jni,需要安装Ndk,可是后期发现在项目里每次均去编译jni导致项目的compile sdk不能使用高于23的,致使Instant Run等功能使用,很影响开发效率.后期改在项目外编译好了静态库然后放入项目中,这样不会限制项目自身的SDK版本,因此若未使用JNI的项目,则可跳过此步骤 6. Git安装及环境变量配置下载安装并配置环境变量 1export GIT_HOME=/usr/android/git-2.12.2/bin 7. Jenkins安装及配置a. 下载下载Jenkins将war包放入Tomcat的webapps目录下,启动tomcat 然后在地址栏输入路径http://localhost:/8777 其中8777为第二步中自定义的端口号 b. 插件安装然后安装插件(基本参考网上的) 12345678910111213141516171819202122231.Branch API Plugin2.build timeout plugin3.build-name-setter4.Credentials Binding Plugin5.description setter plugin6.Dynamic Parameter Plug-in7.Environment Injector Plugin9.Git plugin10.GIT server Plugin11.Gradle Plugin12.Git Parameter Plug-In13.Pipeline: Basic Steps14.Pipeline: Build Step15.Pipeline: Input Step16.Pipeline: Nodes and Processes17.Pipeline: Stage Step18.Scriptler19.Workspace Cleanup Plugin20.Post-Build Script Plug-in21.Email Extension Plugin22.SSH Slaves plugin23.Timestamper(不明为什么少8) 因为Jenkins版本不同,实际使用中发现缺失不少 以下附上笔者所安装的所有插件(若无问题的可跳过) c. 环境变量配置环境变量 首先点击系统管理-&gt;系统设置配置Jdk、Android Sdk、Gradle、Android Ndk环境变量(此处也可配置Git目录,笔者是将Git目录配置在Linux环境变量中了) 其它如邮件相关配置的在下篇会说明 至此环境大体上配置已经完成,下篇即可进入项目相关配置]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>Android</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[混编:Swift调用Objective-C]]></title>
    <url>%2Fhybrid-compile_swift2oc%2F</url>
    <content type="text"><![CDATA[环境 Xcode 8.3.3 Swift3.+ 步骤1.创建混编桥接头文件 名称随便取,最好能和普通header文件做区别 2.项目配置桥接文件 点击工程,选中Build Settings,子选项勾选All 在下面配置中找到(或者搜索)Swift Compile - General 配置混编桥接头文件 点开图中红圈区域进行配置,如我所建的文件在工程里路径为MyProject/Hybrid-Compile.h 则配置也应是这个路径 保存后在该头文件中引用相应OC类头文件即可在Swift中调用 引用注意如果是项目内的OC文件直接引用即可 如果是Pod引用的库中的OC文件则需要带上其Pod中的路径]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
</search>
