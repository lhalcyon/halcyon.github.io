<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux升级Glibc2.14中文乱码]]></title>
    <url>%2F2018%2F02%2F01%2Fupdate_glibc_issue%2F</url>
    <content type="text"><![CDATA[CenterOS上默认的Glibc版本为2.12.1,由于我们的Android项目使用到了JNI,将项目构建部署在服务器上时会遇到问题&#39;GLIBC_2.14&#39; not found,那么就需要升级Glibc至2.14.升级的教程网上很多,可是却漏掉了一个步骤,导致后面中文乱码的问题.本篇会做一个全面的解说 1. Glibc下载首先从Glibc Download下载包,这里选择是Glibc 2.14 2. 安装上传至服务器,进入目录解压 1tar zxvf glibc-2.14.tar.gz 进入解压后的目录 1cd glibc-2.14 接着 12345mkdir /opt/buildcd build../configure --prefix=/opt/glibc-2.14make -j4make install 若顺利的话,至此则安装成功了. issue1. 在make install过程中出现错误: 1Can&apos;t open configuration file /opt/glibc-2.14/etc/ld.so.conf: No such file or directory 缺少了报错的编译文件ld.so.conf.通过find命令找到对应的文件配置 然后拷贝文件至对应文件目录,继续编译 12cp /etc/ld.so.conf /opt/glibc-2.14/etc/ make install 编译成功,接着定义下环境变量即可 3. 补充通常的教程至此就结束了.最初笔者参考网上的教程也是做到这里.当时跑程序也没问题,直到前段时间大楼停电,服务器重启后,通过服务器上Jenkins打包上传到蒲公英的中文信息全是乱码! 相当于服务器的编码文件丢失了,所有中文都会乱码. 是因为遗漏了localedata未编译,在服务器重启后,Glibc2.14找不到对应版本2.14的glibc locale文件. 正确操作是,在make&amp;make install完成后继续编译local包 1make localedata/install-locales 编译需要一些时间,完成后重启服务器即可生效 1shutdown -r now 参考: http://blog.csdn.net/clirus/article/details/62425498 参考: http://blog.csdn.net/fzuzhanghao1993/article/details/77650500]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IDEA+Gradle创建MyBatis+SpringMVC项目]]></title>
    <url>%2F2018%2F01%2F29%2Fssm_build%2F</url>
    <content type="text"><![CDATA[Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建工具.它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置,抛弃了基于XML的各种繁琐配置. IDEA 全称IntelliJ IDEA,是java语言开发的集成环境,IntelliJ在业界被公认为最好的java开发工具之一,尤其在智能代码助手、代码自动提示、重构、J2EE支持、Ant、JUnit、CVS整合、代码审查、 创新的GUI设计等方面的功能可以说是超常的. 以上为百度的简介.从事Android的童鞋应该不难发现Gradle以及Android Studio的强(hen)大(ka).🤫而AS是基于IntelliJ IDEA开发的.习惯了Gradle的便捷,于是开始基于Gradle+IDEA构建Java项目. 环境准备1. 数据库MySql在MySql Downloads下载对应的版本并安装 此处笔者在macOS上安装5.7.21后打开系统偏好设置,遇到无法加载MySql面板的问题.一番搜索🔍后发现是macOS版本与MySql不兼容,选择低版本的MySql如5.6.39即可. 2. IntelliJ IDEA请自行安(po)装(jie). 3. Tomcat请自行下载解压.如若是macOS或是Linux上解压后需进入bin目录执行下命令chmod u+x *.sh修改权限 创建项目点击 Create New Project 选择基于Gradle的Java Web项目 填写GroupId和ArtifactId 选择gradle.可使用默认的,可使用本地的 接着选择项目目录,基本项目创建好了,接下来进入文件配置 文件配置首先创建java和resources目录,并且创建包以及web.xml. log4j.properties12345678910111213141516171819#设置日志的级别，定义日志信息的输出目的log4j.rootLogger=DEBUG, A1 ,R#定义A1的输出目的地为控制台log4j.appender.A1=org.apache.log4j.ConsoleAppender#布局为 PatternLayout 可以灵活地指定布局模式。log4j.appender.A1.layout=org.apache.log4j.PatternLayout#设置输出格式log4j.appender.A1.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH\:mm\:ss&#125; [%c]-[%p] %m%n#定义R的输出目的地为文件，并且文件大小到达指定尺寸的时候产生一个新的文件log4j.appender.R=org.apache.log4j.RollingFileAppender#设置输出的文件地址log4j.appender.R.File=/Users/xx/Documents/ServerLog#设置文件大小伟100 kb 文件到达100时，产生一个新文件，#MaxBackupIndex 最大记录的文件数为1 查过一个文件删除文件较早的。log4j.appender.R.MaxFileSize=100KB log4j.appender.R.MaxBackupIndex=1#以下和上面一样log4j.appender.R.layout=org.apache.log4j.PatternLayoutlog4j.appender.R.layout.ConversionPattern=%p %t %c - %m%n 以上输出文件地址自行更改 generatorConfig.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;classPathEntry location="$&#123;jarDirection&#125;"/&gt; &lt;context id="mysql" targetRuntime="MyBatis3"&gt; &lt;jdbcConnection driverClass="$&#123;driverClass&#125;" connectionURL="$&#123;connectionURL&#125;" userId="$&#123;userId&#125;" password="$&#123;password&#125;"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver &gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;javaModelGenerator targetPackage="$&#123;modelPackage&#125;" targetProject="$&#123;src_main_java&#125;"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage="$&#123;sqlMapperPackage&#125;" targetProject="$&#123;src_main_java&#125;"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/sqlMapGenerator&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="$&#123;mapperPackage&#125;" targetProject="$&#123;src_main_java&#125;"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 每一个数据库表都对应一个对应的table属性 --&gt; &lt;table tableName="book" domainObjectName="Book"&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; gradle.properties123456# 生成的model类所在包modelPackage=com.lhalcyon.webhook.domain# 生成的mapper接口类所在包mapperPackage=com.lhalcyon.webhook.mapper# 生成的mapper xml文件所在包sqlMapperPackage=com.lhalcyon.webhook.mapper 为了方便扫描,将mapper xml以及接口类放在了同一包下了 😕 jdbc-mysql.properties12345678910# 将jdbc.jarDirection后的内容更改为gradle下载的# mysql-connector-java-5.1.x.jar所在的路径，gradle自动下载的路径如下所示jdbc.jarDirection=/Users/ceyx/.gradle/caches/modules-2/files-2.1/mysql/mysql-connector-java/5.1.38/dbbd7cd309ce167ec8367de4e41c63c2c8593cc5/mysql-connector-java-5.1.38.jarjdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/halcyonjdbc.user=rootjdbc.pass=root 自行填写jdbc.jarDirection路径 build.gradle123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596group 'com.lhalcyon'version '1.0-SNAPSHOT'apply plugin: 'java'apply plugin: 'war'sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;configurations &#123; mybatisGenerator&#125;// 读取config文件夹中对应的配置文件ext&#123; def prop = new Properties(); file("src/main/resources/config/mybatis/jdbc-mysql.properties") .withInputStream &#123; prop.load(it) &#125; file("src/main/resources/config/mybatis/gradle.properties") .withInputStream &#123; prop.load(it) &#125; prop.each &#123; project.extensions.add("$it.key",it.value); &#125;&#125;dependencies &#123; testCompile group: 'junit', name: 'junit', version: '4.12' compile 'org.codehaus.groovy:groovy-all:2.3.11' compile 'jstl:jstl:1.2' compile 'org.springframework:spring-aop:4.2.4.RELEASE' compile 'org.springframework:spring-context:4.2.4.RELEASE' compile 'org.springframework:spring-beans:4.2.4.RELEASE' compile 'org.springframework:spring-web:4.2.4.RELEASE' compile 'org.springframework:spring-webmvc:4.2.4.RELEASE' compile 'org.springframework:spring-tx:4.2.4.RELEASE' compile 'org.springframework:spring-jdbc:4.2.4.RELEASE' compile 'org.springframework:spring-test:4.2.4.RELEASE' compile 'mysql:mysql-connector-java:5.1.38' compile 'org.mybatis.generator:mybatis-generator-core:1.3.2' compile 'org.mybatis:mybatis-spring:1.2.3' compile 'org.mybatis:mybatis:3.3.0' compile 'junit:junit:4.12' compile group: 'commons-dbcp', name: 'commons-dbcp', version: '1.4' compile group: 'org.aspectj', name: 'aspectjweaver', version: '1.8.13' compile group: 'log4j', name: 'log4j', version: '1.2.17' mybatisGenerator 'org.mybatis.generator:mybatis-generator-core:1.3.2' mybatisGenerator 'mysql:mysql-connector-java:5.1.38'&#125;// 利用ant创建一个自动生成MyBatis目录文件的tasktask mybatisGenerate &lt;&lt; &#123; ant.properties['targetProject'] = projectDir.path ant.properties['jarDirection'] = project['jdbc.jarDirection'] ant.properties['driverClass'] = project['jdbc.driverClassName'] ant.properties['connectionURL'] = project['jdbc.url'] ant.properties['userId'] = project['jdbc.user'] ant.properties['password'] = project['jdbc.pass'] ant.properties['src_main_java'] = sourceSets.main.java.srcDirs[0].path ant.properties['src_main_resources'] = sourceSets.main.resources.srcDirs[0].path ant.properties['modelPackage'] = project['modelPackage'] ant.properties['mapperPackage'] = project['mapperPackage'] ant.properties['sqlMapperPackage'] = project['sqlMapperPackage'] ant.taskdef( name: 'mbgenerator', classname: 'org.mybatis.generator.ant.GeneratorAntTask', classpath: configurations.mybatisGenerator.asPath ) ant.mbgenerator(overwrite: true, configfile: 'src/main/resources/config/mybatis/generatorConfig.xml', verbose: true) &#123; propertyset &#123; propertyref(name: 'targetProject') propertyref(name: 'jarDirection') propertyref(name: 'userId') propertyref(name: 'driverClass') propertyref(name: 'connectionURL') propertyref(name: 'password') propertyref(name: 'src_main_java') propertyref(name: 'src_main_resources') propertyref(name: 'modelPackage') propertyref(name: 'mapperPackage') propertyref(name: 'sqlMapperPackage') &#125; &#125;&#125; 接着Sync或者点击Import Changes IDEA就会下载依赖包了.依赖版本号均源于Maven Repository spring-mvc.xml 导入依赖后,则可直接创建spring相关xml 123456789101112131415161718192021222324&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 自动扫描控制器 --&gt; &lt;context:component-scan base-package="com.lhalcyon.webhook.controller"/&gt; &lt;!-- 视图渲染 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/views/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;!-- 控制器映射器和控制器适配器 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源映射器 --&gt; &lt;mvc:resources mapping="/statics/**" location="/WEB-INF/statics/" /&gt;&lt;/beans&gt; applicationContext-dao.xml123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 加载配置文件 --&gt; &lt;context:property-placeholder location="classpath:config/mybatis/jdbc-mysql.properties" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.user&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.pass&#125;" /&gt; &lt;property name="maxActive" value="10" /&gt; &lt;property name="maxIdle" value="5" /&gt; &lt;/bean&gt; &lt;!-- mapper配置 --&gt; &lt;!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;!--&lt;property name="mapperLocations" value="classpath*:com/lhalcyon/mapper/*.xml"/&gt;--&gt; &lt;/bean&gt; &lt;!-- 配置Mapper扫描器 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.lhalcyon.webhook.mapper"/&gt; &lt;/bean&gt;&lt;/beans&gt; applicationContext-service.xml1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 配置包扫描器 --&gt; &lt;context:component-scan base-package="com.lhalcyon.webhook.service"/&gt;&lt;/beans&gt; applicationContext-trans.xml1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 数据源 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:method name="insert*" propagation="REQUIRED" /&gt; &lt;tx:method name="delete*" propagation="REQUIRED" /&gt; &lt;tx:method name="update*" propagation="REQUIRED" /&gt; &lt;tx:method name="query*" propagation="SUPPORTS" read-only="true" /&gt; &lt;tx:method name="get*" propagation="SUPPORTS" read-only="true" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 切面 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* com.lhalcyon.webhook.service.*.*(..))" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt; &lt;!-- 初始化spring 容器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring/applicationContext-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;index-dispather&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:config/spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;index-dispather&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 解决post乱码问题 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; Tomcat部署Run-&gt;Edit Configurations 有fix项点击配置即可,然后运行. MyBatis配置数据库管理工具笔者使用的是 首先创建数据库halcyon,接着创建book表,用于后面的mybatis generator 12345CREATE TABLE book ( book_id INT PRIMARY KEY AUTO_INCREMENT, book_name VARCHAR(30) NOT NULL, author VARCHAR(20) default '佚名') 然后在gradle创建mybatis generator task 运行task 运行成功后,会生成与数据库表对应的java bean与dao文件,即项目里的Book.java、BookExample.java、BookMapper.xml、BookMapper.java generatorConfig.xml配置参数可自行搜索补充修改🤔.手动覆写下Book的toString方法方便日志输出 测试为了满足同时测试Spring、SpringMVC、Mybatis,笔者建立一个Controller通过Get请求进行CURD操作. Service1234567891011121314151617181920212223242526272829@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired private BookMapper bookMapper; @Override public void insertBook(Book book) &#123; bookMapper.insert(book); &#125; @Override public void updateBook(Book book) &#123; bookMapper.updateByPrimaryKey(book); &#125; @Override public List&lt;Book&gt; getAllBooks() &#123; BookExample example = new BookExample(); return bookMapper.selectByExample(example); &#125; @Override public void deleteBookById(int bookId) &#123; BookExample example = new BookExample(); example.createCriteria().andBookIdEqualTo(bookId); bookMapper.deleteByExample(example); &#125;&#125; Controller1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@RestControllerpublic class BookController &#123; private static final Logger logger = Logger.getLogger(BookController.class); @Autowired private BookService bookService; @RequestMapping(value = "/insert",method = RequestMethod.GET) public String insert(String bookName,String author)&#123; Book book = new Book(); book.setBookName(bookName); book.setAuthor(author); bookService.insertBook(book); return queryStrings(); &#125; @RequestMapping("/update") public String updateAuthor(int bookId,String bookName,String author)&#123; Book book = new Book(); book.setBookId(bookId); book.setBookName(bookName); book.setAuthor(author); bookService.updateBook(book); return queryStrings(); &#125; @RequestMapping("/delete") public String deleteBook(int bookId)&#123; bookService.deleteBookById(bookId); return queryStrings(); &#125; @RequestMapping("/find_all") public String getAllBooks()&#123; List&lt;Book&gt; books = bookService.getAllBooks(); logger.info(books); return books.toString(); &#125; private String queryStrings()&#123; List&lt;Book&gt; allBooks = bookService.getAllBooks(); return allBooks.toString(); &#125;&#125; 直接通过请求地址,获得结果 插入: 1http://localhost:8080/webhook/insert?bookName=java&amp;author=jack 执行后直接将数据库中所有book记录输出,方便观察. 其它操作类似 更新: 1http://localhost:8080/webhook/update?bookId=3&amp;bookName=go&amp;author=joe 删除: 1http://localhost:8080/webhook/delete?bookId=4 查询(所有): 1http://localhost:8080/webhook/find_all 如若发生500 Invalid bound statement (not found)类似错误,一般是没有扫描到Mapper.xml.其中一种情况下是xml根本没被打包进war.需要在build.gradle中进行配置,并且配置后Sync或Import Changes,再重新用命令./gradlew build才可生效. 123456//将src文件夹中的资源文件同时打包processResources &#123; from(&apos;src/main/java&apos;) &#123; include &apos;**/*.xml&apos; &#125;&#125; 至此SpringMVC+MyBatis+Gradle项目已经构建测试完毕. 代码已上传GayHub,文章若对各位大佬有帮助,麻烦顺手点个star~ ❤️ 各位可能发现了,SSM配置起来比较繁琐,相比之下,SpringBoot就精简了许多.后面有机会,我们再来细说 🤒 参考: https://www.cnblogs.com/bojuetech/p/5844413.html 参考: http://blog.csdn.net/kingboyworld/article/details/78251425]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Studio版本兼容Api警告]]></title>
    <url>%2F2017%2F09%2F25%2Fas_warning%2F</url>
    <content type="text"><![CDATA[Android Studio版本兼容Api警告最近在开发中,组内的小伙伴在开发中使用了高版本SDK25的Api,但是我们的项目最低兼容14,因此测试在5.1上的手机直接就崩溃了,问其在开发中没有看到警告吗,回复说确实没看到.后来查究一下,他的工具上确实没有显示.本文简述下如何手动去调整兼容Api的提示等级,避免在开发中用到高版本的Api却不自察. 首先win电脑是打开Android Studio的 Setting ,mac是打开Android Studio的 Preferences 选择Editor中的Inspections 对Calling new methods on older versions进行勾选并且配置为Error级别 如此简单即可搞定.如遇到其他警告,错误代码没提示也可类似进行操作配置.]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Xcode代码提示问题处理]]></title>
    <url>%2F2017%2F08%2F15%2Fxcode-idiot%2F</url>
    <content type="text"><![CDATA[最近在写Swift.对于笔者这种被JetBrains的几大IDE工具给惯坏的开发者,Xcode的代码提示真是无力吐槽,先不论智能提示度,就连基本的提示也经常出不来.这里就简单总结下iOS同事传授的几招解决办法 1.Clean Project最直接的办法就是清空项目. 可视化按钮入口再哪请自行查找,笔者一般是用Command+Shift+K进行清空,此方法一般有效,缺点是会重新编译项目,比较慢 2.清空Xcode缓存前往Xcode的缓存目录,清空项目编译缓存. 具体操作为右键Finder前往文件夹文件夹路径为/用户/ceyx/资源库/Developer/Xcode/DerivedData 其中ceyx 替换为自己的用户名,删除目录下所有文件,然后重新打开Xcode,编译. 此方法比1更慢,往往也更有效 3.终极大招如若上述两种方法还无效,只能使用绝招了…重启Xcode,还不行就重启电脑… 笔者黔驴技穷了,只能充当下网吧老板传授下终极大招.👻 题外话,对于JetBrains出品的appcode还未尝试过,不知对于Xcode项目兼容到何程度,是否支持Cocoapod等,有时间会去体验下,希望至少在代码提示上能更友善些😀 笔者去体验了下Appcode,其代码提示和快捷键如Jetbrains其他产品一样非常智能,但是代码中偶有飘红,却可以成功运行,比较干扰编码.尤为尴尬的一点是,Appcode不支持storyboard,即在项目内点开storyboard文件就直接跳转xcode了😥. 如真的被Xcode逼疯的童鞋可以考虑下用AppCode编码,用Xcode操作storyboard]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux+Jenkins+Gradle构建Android参数化自动打包(二)]]></title>
    <url>%2F2017%2F07%2F20%2Flinux-jenkins-gradle_build_android2%2F</url>
    <content type="text"><![CDATA[在前一篇文章中,说明了在CenterOS上进行一系列的环境搭建,本文开始说明关于项目的一系列配置 Jenkins项目配置首先创建一个项目,将构建保持的天数和个数进行限制 此处感谢后台同事提示,因为Android SDK NDK 就特别占空间了,如果构建缓存不进行限制,则很快服务器空间就会不足🤥 参数构建配置打包环境 分支指定 email自定义接收者 打包时间戳 因为笔者的公司对打包的Apk名以及测试版本号时间戳显示的要求,因此需要使用动态参数 还有其他参数均与以上类似,可自行配置 !!! 记住尤为重要的是这些参数都是Jenkins上配置的Gradle属性,得传递到App的Gradle中 这里勾选Pass all job parameters as Project properties 源码管理在源码管理处配置Git账号 这里的*/${BRANCH}对应参数配置时的BRANCH.为什么这里做成选择型参数呢,是因为分支名是未知的,做成填写的话,可能压根拉不到指定分支的代码🤐 Gradle构建脚本增加构建动作 这里${WORKSPACE}指的是Git拉下的根目录.途中马赛克位置则为项目根目录 蒲公英上传增加构建动作,将Apk上传蒲公英 1curl -k -F &quot;file=@$&#123;WORKSPACE&#125;/source/项目根目录/app/apks/$&#123;BUILD_PREFIX&#125;_$&#123;JENKINS_TIME&#125;_$&#123;DAY_VERSION&#125;.apk&quot; -F &quot;uKey=你的ukey&quot; -F &quot;_api_key=你的apiKey&quot; -F &quot;installType=2&quot; -F &quot;password=hljj&quot; -F &quot;updateDescription=$&#123;DESCRIPTION&#125;&quot; https://www.pgyer.com/apiv1/app/upload ${WORKSPACE}/source/项目根目录/app/apks/为笔者自行修改的Apk输出目录,此处请根据自己的项目输入目录进行修改 curl命令如果使用不了可自行百度解决 以下为蒲公英的上传Api,可以自行调整参数 邮件通知首先还是进入Jenkins-&gt;系统设置 在Jenkins Location中进行配置 Jenkins URL:http://10.50.0.16:8777/jenkins/ 系统管理员邮件地址: Android参数化构建&lt;aaa@163.com&gt; 此处Android参数化构建就为邮件中的发送人名称 系统设置中的默认收件人最好不要配置为自己,因为如果配置后,自己就永远在收件人的前端,后面想发送给领导时,便不大好. 邮件的内容可自定义html内容,二维码直接线下生成蒲公英的地址然后贴在邮件内即可 App本地Gradle配置首先在gradle.properties文件中进行参数化构建在非Jenkins写入情况时的缺省值配置 在未使用Jenkins构建的情况下应用会读本地的这些变量值 然后在appmodule下的build.gradle中进行配置写入的值配置 12345678910111213141516171819202122232425262728293031323334//修改生成的apk名字及输出目录applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def newName def oldFile = output.outputFile def outDirectory = oldFile.parent def buildPrefix def showVersion if (variant.buildType.name == &apos;debug&apos;) &#123; buildPrefix = BUILD_PREFIX &#125; else &#123; buildPrefix = BUILD_PREFIX_RELEASE &#125; def jenkinsTime = JENKINS_TIME if (variant.buildType.name == &apos;debug&apos;) &#123; showVersion = buildPrefix + &apos;_&apos; + jenkinsTime + &apos;_&apos; + DAY_VERSION &#125; else &#123; showVersion = APP_VERSION &#125; resValue(&quot;string&quot;, &apos;fund_app_version&apos;, showVersion) def tempFile = file(&quot;build.gradle&quot;) outDirectory = tempFile.parent + &apos;/apks&apos; if (IS_JENKINS) &#123; newName = buildPrefix + &apos;_&apos; + jenkinsTime + &apos;_&apos; + DAY_VERSION + &apos;.apk&apos; &#125; else &#123; newName = &apos;android-v&apos; + APP_VERSION + &apos;-&apos; + variant.productFlavors[0].name + &apos;-&apos; + variant.buildType.name + &apos;.apk&apos; &#125; output.outputFile = new File(outDirectory, newName) &#125;&#125; 系统默认的输入路径是在build文件夹中,层级比较深.此处笔者将apk的输出路径进行了修改并且对apk的输出名称进行了调整 至此,Jenkins参数自动化构建已经完成!😀]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux+Jenkins+Gradle构建Android参数化自动打包(一)]]></title>
    <url>%2F2017%2F07%2F07%2Flinux-jenkins-gradle_build_android1%2F</url>
    <content type="text"><![CDATA[前言在文章开始前,先说下写这篇文章产出的原因及环境. 关于Jenkins部署安卓自动打包有很多好处,可以配置参数进行构建,选择打包环境、设置App版本、设置加密开关等.起初,笔者也是参考了一些网上的教程,将自动化打包构建在了自己的windows开发机器上,而将Jenkins自动构建Android部署在服务器上和本机上在环境构建方面略有不同,坑略多. 参数化构建的过程却是很便捷,但是部署在本机上自动化打包其实是个会增加打包时长的工作,因为自动化打包会首先去代码仓库拉取代码到本地,然后再开始打包,这个过程会比直接用AS打包慢很多.后来提出需求,要将自动化打包配置到服务器上.运维就提供了一台Linux服务器,并且上面已配置后台的自动化打包环境,用的是Jdk1.7和比较旧版本的Jenkins,于是我们得另行使用独立的安装的环境. 最终结果最终我们要实现的是实现Jenkins上面配置应用版本号、Git分支、应用渠道、请求基地址、应用环境等参数,进行一键参数化构建打包上传至蒲公英并发送邮件通知给自定义的接收者 最终实现参数化配置大致如下所示: 发送邮件(邮件内容较长,进行了相应缩小) 环境搭建所需环境 新版Jenkins(需能安装参数化构建插件) Tomcat 新版Jenkins Android SDK Android NDK aapt Git Gradle 其它(视自身项目所需) CenterOS64位已有环境 Jdk1.7 Tomcat 旧版Jenkins 1. Jdk安装及配置由于Android开发使用的 Jdk1.8,因此不能复用服务器上现有的Jdk 首先去Oracle Downloads下载 Jdk for Linux.笔者下载的是jdk-8u131-linux-x64.tar.gz 上传到服务器,进入相关目录解压 1tar -zxvf jdk-8u131-linux-x64.tar.gz 可将目录移至其他目录.其实最好在解压前就将压缩包移至目标目录 Jdk环境变量配置(可选) 由于后台使用了JAVA_HOME、JENKINS_HOME等一系列环境变量名,所以服务器上默认调用的会是他们的环境变量,我们开发的一套只能在自己的Tomcat、Jenkins中进行指定,具体下文会进行说明 2. Tomcat安装及配置首先去Tomcat Download选择版本进行下载.这里笔者选择的是apache-tomcat-7.0.79.tar.gz 上传到服务器,进入相关目录解压 1tar -zxv -f apache-tomcat-7.0.79.tar.gz a.端口修改由于常规tomcat端口被已有tomcat占用,因此我们需要修改端口 进入conf目录下的server.xml修改,此处笔者是用Vim修改.不会用的同学请出门左转度娘🤔 主要修改的是,设置为自定义端口号 Tomcat admin port 即文件最上面的端口号 Http/1.1 port 连接访问的端口号 AJP/1.3 port b.环境配置指定Tomcat运行时环境,在bin目录下修改setclasspath.sh 以下是笔者的环境,请自行替换路径 123export JAVA_HOME=/usr/android/java/jdk1.8.0_131export JRE_HOME=/usr/android/java/jdk1.8.0_131/jreexport JENKINS_HOME=/home/android/jenkins 3. Gradle安装及配置首先去Gradle Download下载对应Gradle版本,笔者使用到的是gradle-3.3-all.zip 上传到指定目录解压 1unzip gradle-3.3-all.zip 然后添加环境变量vim /etc/profile,在环境变量配置处增加一句 1export GRADLE_HOME=/home/gradle-3.3/bin 4. Android Sdk For Linux 安装及更新这里下载Sdk解压都不是难点.难点在于安装之后更新的问题. 用AS或者Eclipse的同学肯定接触过Sdk Manager,此处选择更新后要手动点Accept License才能启动更新.但是在Linux下没有界面化的勾选可用.因此需要用脚本来更新.网上有说复制License的方法笔者试了无效,也许是姿势不对吧,此处也是踩了很久的坑才搜出来的解决方法: 更新Sdk方法传送门 这里先感谢下该作者👏 这里也为不愿跳传送门的同学说明一下,就几个步骤. a.查看可更新列表 在Sdk的tools目录使用./android list sdk --all查看远程服务器提供的Sdk包的序号,记录想要更新的Sdk序号 b.编辑脚本 1234567#!/usr/bin/expectset timeout -1spawn /usr/local/android-sdk-linux/tools/android update sdk -u -a -t 1,2,3,24,25,26,27,28,30,95,96,102,103,104,105,106,107expect &#123; &quot;Do you accept the license&quot; &#123; exp_send &quot;y\r&quot; ; exp_continue &#125; eof&#125; 此处1,2,3,...为需要下载的Sdk序号 c.运行脚本 待脚本跑完,sdk就更新完毕了 注意此处脚本用到了expect,需要在服务器上安装,此处提供expect安装传送门 5. Ndk for Linux安装安装较简单,后续需配置Jenkins系统变量,下文会进行说明 项目因用到了Jni,需要安装Ndk,可是后期发现在项目里每次均去编译jni导致项目的compile sdk不能使用高于23的,致使Instant Run等功能使用,很影响开发效率.后期改在项目外编译好了静态库然后放入项目中,这样不会限制项目自身的SDK版本,因此若未使用JNI的项目,则可跳过此步骤 6. Git安装及环境变量配置下载安装并配置环境变量 1export GIT_HOME=/usr/android/git-2.12.2/bin 7. Jenkins安装及配置a. 下载下载Jenkins将war包放入Tomcat的webapps目录下,启动tomcat 然后在地址栏输入路径http://localhost:/8777 其中8777为第二步中自定义的端口号 b. 插件安装然后安装插件(基本参考网上的) 12345678910111213141516171819202122231.Branch API Plugin2.build timeout plugin3.build-name-setter4.Credentials Binding Plugin5.description setter plugin6.Dynamic Parameter Plug-in7.Environment Injector Plugin9.Git plugin10.GIT server Plugin11.Gradle Plugin12.Git Parameter Plug-In13.Pipeline: Basic Steps14.Pipeline: Build Step15.Pipeline: Input Step16.Pipeline: Nodes and Processes17.Pipeline: Stage Step18.Scriptler19.Workspace Cleanup Plugin20.Post-Build Script Plug-in21.Email Extension Plugin22.SSH Slaves plugin23.Timestamper(不明为什么少8) 因为Jenkins版本不同,实际使用中发现缺失不少 以下附上笔者所安装的所有插件(若无问题的可跳过) c. 环境变量配置环境变量 首先点击系统管理-&gt;系统设置配置Jdk、Android Sdk、Gradle、Android Ndk环境变量(此处也可配置Git目录,笔者是将Git目录配置在Linux环境变量中了) 其它如邮件相关配置的在下篇会说明 至此环境大体上配置已经完成,下篇即可进入项目相关配置]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[混编:Swift调用Objective-C]]></title>
    <url>%2F2017%2F06%2F20%2Fhybrid-compile_swift2oc%2F</url>
    <content type="text"><![CDATA[环境 Xcode 8.3.3 Swift3.+ 步骤1.创建混编桥接头文件 名称随便取,最好能和普通header文件做区别 2.项目配置桥接文件 点击工程,选中Build Settings,子选项勾选All 在下面配置中找到(或者搜索)Swift Compile - General 配置混编桥接头文件 点开图中红圈区域进行配置,如我所建的文件在工程里路径为MyProject/Hybrid-Compile.h 则配置也应是这个路径 保存后在该头文件中引用相应OC类头文件即可在Swift中调用 引用注意如果是项目内的OC文件直接引用即可 如果是Pod引用的库中的OC文件则需要带上其Pod中的路径]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
</search>
