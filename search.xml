<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Flutter基础-(4)widget-图片Image]]></title>
    <url>%2Fflutter-widget-image%2F</url>
    <content type="text"><![CDATA[本篇将讲解图片加载及特定平台图片处理. 为了更好的阅读体验 , 请点击 阅读原文 概览Image 是用来展示图片的 widget. 系统提供着不同方式去构造 Image : new Image, 从 ImageProvider 获取图片 new Image.asset , 从 AssetBundle 获取图片 new Image.network , 从网络获取图片 new Image.file , 从File获取图片 new Image.memory , 从 Uint8List 获取图片 Image 支持以下图片格式 : JPEG , PNG ,GIF , 动态 GIF , WebP , 动态WebP , BMP WBMP . 直接上示例 图中三个示例分别表示 从Assets加载图片 从网络加载图片并缓存在内存中 从网络加载图片并缓存在内存中且以渐现动画的形式展示 . 1 类似 Android 从 mipmap或drawable 下获取图片; iOS 从Assets.xcassets 中读取图片 2 常规的从网络加载图片,可选缓存在文件或者内存中. 3 移动应用中常用的图片展示效果. Assets加载图片Flutter 使用 pubspec.yaml文件定位项目根目录,识别app所需要的资产 示例: 123flutter: assets: - assets/images/ic_link.png 注意此处资产路径是根目录下的路径.示例中assets和源码lib是同级目录 加载代码: 1234567891011Widget build(BuildContext context) &#123; // ... var imageAssets = 'assets/images/ic_link.png'; return new Image.asset( imageAssets, width: 150.0, height: 150.0, ) ); // ...&#125; 或 1234567891011Widget build(BuildContext context) &#123; // ... var imageAssets = 'assets/images/ic_link.png'; return new Image( image: new AssetImage(imageAssets), width: 150.0, height: 150.0, ) ); // ...&#125; 以上为加载当前项目中的资产图片.当从依赖包中加载图片时,需要加上依赖包名 例如我们的应用依赖三方包 flutter_gallery_assets ,它有着以下目录结构 …/pubspec.yaml …/lib/ali_connors.png 我们就需要用以下代码来加载图片 1new AssetImage('ali_connors.png', package: 'flutter_gallery_assets') 同时还需要去 pubspec.yaml 文件中申明 123assets: - assets/images/ic_link.png - packages/flutter_gallery_assets/ali_connors.png 注意: ali_connors.png 文件路径其实为 flutter_gallery_assets-版本号/lib/ali_connors.png 其中lib作为三方包时是隐式包含了, 不需要我们自己添加 File加载图片直接上代码 123456789101112Widget build(BuildContext context) &#123; // ... var imagePath = '/Users/xx/Downloads/cow.png'; return new Image( image: new FileImage(new File(imagePath)), repeat: ImageRepeat.noRepeat, width: 150.0, height: 150.0, ) ); // ...&#125; 注意: 这里imagePath作为绝对路径读的是计算机上的图片地址 , 找不到本机图片时不会显示 . 因为平台关系 , 相对路径一般访问不到 , 需要通过三方包 path_provider 来提供与平台无关的访问设备文件的方法.届时还需要将图片导入到设备中 ,此处就不作展开 网络加载图片应用中网络加载图片的场景许多 , 先给出一个简单的示例: 1234567891011Widget build(BuildContext context) &#123; // ... var imgUrl = 'https://ws1.sinaimg.cn/large/006tNc79gy1fpa5bvsqskj3044048mx5.jpg'; return new Image.network( imgUrl, width: 150.0, height: 150.0, ) ); // ...&#125; 或 1234567891011Widget build(BuildContext context) &#123; // ... var imgUrl = 'https://ws1.sinaimg.cn/large/006tNc79gy1fpa5bvsqskj3044048mx5.jpg'; return new Image( image: new NetworkImage(imgUrl), width: 150.0, height: 150.0, ) ); // ...&#125; 这种只是简单的加载网络图片,若图片较大,或者网络卡顿.图片显示的效果就显得很突兀(可参考上面gif ) , 此时我们需要给图片呈现加一段渐现的Fading动画. FadeInImage FadeInImage更符合应用中的场景 , 渐现呈现网络图片,并且缓存到内存 12345678910111213141516import 'package:transparent_image/transparent_image.dart';Widget build(BuildContext context) &#123; // ... var imgUrl = 'https://ws1.sinaimg.cn/large/006tNc79gy1fpa5bvsqskj3044048mx5.jpg'; return new FadeInImage.memoryNetwork( placeholder: kTransparentImage, image: imgUrl, width: 150.0, height: 150.0, fadeInDuration: const Duration(milliseconds: 1200), fadeOutDuration: const Duration(milliseconds: 1200), ) ); // ...&#125; 示例效果请参考上面的gif效果图 , 其中用到了三方库 transparent_image 主要作用是使用其透明图片作为占位图 可使用 FadeInImage.assetNetwork 实现文件缓存. 若想实现 Android 中 Glide ,Picasso , iOS 中 Kingfisher 这样的图片三级缓存框架 , 就需要自行封装实现了. 这里我们可以发现 , 我们未主动地在Android应用清单文件中申明网络权限,Flutter默认已经授予了网络权限用以提供热部署等等. 分辨率处理手机有不同的像素比率 , 这时就需要根据手机的像素比率来加载不同图片 . 做法很简单,只需要在图片同级目录下创建 2.0x/abc.png 和 3.0x/abc.png 的目录即可 在 pubspec.yaml 中定义的assets路径不需要增加 2.0x 3.0x 例如以前图片是 123flutter: assets: - assets/images/ic_link.png 加入分辨率目录后不变 , 依然是该路径 特定平台图片对于 Android , iOS 特定平台的资产图片需要我们去对应的平台文件夹下去设置 . 以下为两个常见的场景 , 我们将在Flutter框架运行前使用到图片资产 更新应用图标更新应用图标的方式与在开发原生Android,iOS应用时一样. Android 在项目根目录下的 .../android/app/src/main/res里,默认应用图标为ic_launcher.png ,可分别替换对应分辨率下的图片从而更新应用图标 iOS 在项目根目录下的 .../ios/Runner/Assets.xcassets/AppIcon.appiconset , 替换相应图片从而更新应用图标 更新启动页Android Flutter 默认设置了个启动页 .../android/app/src/main/res/drawable/launch_background.xml . 可通过修改该文件来定制个性化的元素 iOS 在 .../ios/Runner/Assets.xcassets/LaunchImage.imageset , 放置LaunchImage.png ,LaunchImage@2x.png , LaunchImage@3x.png. 若用到不同的文件名称 , 需要在同目录下更新 Contents.json中的文件名称 还可以通过打开…/ios/Runner.xcworkspace , 来完全定制启动屏幕storyboard . 好了, 关于 Image 的部分就讲到这里了. 相关代码已经上传 GitHub ,如有帮到你, 请不吝点个Star🤗]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter基础-(3)Widget-文本Text]]></title>
    <url>%2Fflutter-widget-text%2F</url>
    <content type="text"><![CDATA[本来打算第三篇文章来讲解 Flutter 单子布局widget , 奈何 18种单子布局widget 内容颇多,加之年后有了新项目要开发 , 使得文章产出周期被拉长 :( . 这里先来篇简单的关于Text的文章 , 下次更新将会发出 Flutter系列的目录及布局widget的文章. TextText 文本是app里常见的控件 , 用以显示一串单一样式的文本 . 该字符串可跨越多行 , 或根据布局约束显示在同一行中 最简单的可以直接用这样的代码来展示文本 , 类似 Android 里的 TextView , iOS 里的 UILabel . 1new Text('简单的文本') 代码未指定样式 , 此时将使用最近的 DefaultTextStyle 样式 . 若给定样式中 TextStyle.inherit 属性为true , 给定样式则将与最近的 DefaultTextStyle 样式合并 . 类似 Android 里 , style.xml 主题样式 AppTheme 中定义了文本样式 , 并且将其设置为 Application 的主题样式 , 那么新建一个 TextView 就会默认使用 AppTheme中定义的文本样式 , 而当给这个 TextView 设置样式时,此样式就会和主题样式进行合并 当 TextStyle.inherit 属性设置为 false 时 , 文本样式会恢复到默认状态: 白色, 10像素 , sans-serif 字体 12345final TextStyle _inheritBigFont = new TextStyle(inherit: true, fontSize: 24.0);final TextStyle _notInheritBigFont = new TextStyle(inherit: false, fontSize: 24.0);...new Text('inherit true', style: widget._inheritBigFont)new Text('inherit false', style: widget._notInheritBigFont) 文本样式鸟瞰 RichText要显示多样式的文本 , 需要使用富文本 RichText 在开发中 , 有一些常见的应用场景需要用到富文本 . 比如在很多 app 注册 ,开户界面会有一个同意协议的模块 , 我已阅读并同意《xxx协议》 , 协议名称通常高亮显示并且可以点击打开协议页面 . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import 'package:flutter/gestures.dart';import 'package:flutter/material.dart';class DemoText extends StatefulWidget &#123; final TextStyle _protocolFont = new TextStyle(fontSize: 16.0); final TextStyle _inheritBigFont = new TextStyle(inherit: true, fontSize: 24.0); final TextStyle _notInheritBigFont = new TextStyle(inherit: false, fontSize: 24.0); @override DemoTextState createState() &#123; return new DemoTextState(); &#125;&#125;class DemoTextState extends State&lt;DemoText&gt; &#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: const Text('Text Demo'), ), body: new Builder(builder: builderBody)); &#125; Widget builderBody(BuildContext context) &#123; final TapGestureRecognizer recognizer = new TapGestureRecognizer(); recognizer.onTap = () &#123; Scaffold.of(context).showSnackBar(new SnackBar( content: new Text('协议被点击!'), )); &#125;; final Divider divider = new Divider(color: Colors.white, height: 2.0); return new Container( color: Colors.grey, alignment: Alignment.center, child: new Column( children: &lt;Widget&gt;[ new Text('inherit true', style: widget._inheritBigFont), new Text('inherit false', style: widget._notInheritBigFont), divider, new Text( '龙骑士囧雪诺JohnSnow', style: new TextStyle( color: Colors.blue, fontSize: 24.0, fontStyle: FontStyle.italic, letterSpacing: 2.0, decoration: TextDecoration.underline), ), divider, new RichText( text: new TextSpan( text: '我已阅读', style: widget._protocolFont, children: &lt;TextSpan&gt;[ new TextSpan( text: '《从flutter入门到放弃》', style: new TextStyle(color: Colors.redAccent), recognizer: recognizer), ], ), ), ], )); &#125;&#125; TapGestureRecognizer 是手势识别者 , 后面讲到手势时再具体说明 . 这里我们先知道它可以用来给富文本某一段添加点击事件 . 这里我们点击协议后 , 会弹出一个SnackBar提示协议被点击了 .]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter基础-(2)基本概念及首个应用]]></title>
    <url>%2Fflutter-basic-concept%2F</url>
    <content type="text"><![CDATA[在 上一篇文章 中,我们讲解了 Flutter 开发环境搭建 , 以及运行了官方demo简单体验了下 Flutter app . 此篇我们将开始对一些 Flutter app 中的一些基本概念进行讲解 , 一些基本的操作做一些示例 , 主要是参考官网的教程 Write Your First Flutter App 若你对面向对象编程熟悉,以及对基本编程概念如变量、循环、条件了解 , 则适合阅读本篇文章 . 不必需要拥有 Dart 或移动编程经验. 为了更好的阅读体验 , 请点击 阅读原文 :) 步骤 1 : 创建及启动 Flutter app 步骤 2 : 使用一个外部的程序包 步骤 3 : 增加一个 Stateful Widget 步骤 4 : 创建一个无限滚动的 ListView 步骤 5 : 增加交互 步骤 6 : 跳转到新页面 步骤 7 : 通过主题改变UI 完成! 我们将创建什么我们将实现一个简单的移动应用 , 它会生成创业公司的名称 . 用户可以选择和反选名称 , 保存喜好的那些 . 代码一次生成 10 个名称 . 当用户滑动时 , 新一批的名称就会生成 . 用户可以点击导航栏右上的按钮进入一个只展示喜好的名称的列表新页面. 我们将学到: Flutter app 的基本结构 使用额外的包去拓展功能 使用热部署来快速开发 如何去实现一个stateful 小部件 如何创建一个无线滑动,懒加载的列表 如何跳转去下一个界面 如果通过主题去修改app外观 步骤 1 : 创建及启动 Flutter app这里创建一个简单的 flutter app 123flutter create flutter_first_appcd flutter_first_appflutter run 如有疑问 , 可参考 前一篇文章 指引 简单地 , 我们先将 lib/main.dart中的代码全部删除 , 替换为以下代码 , 其主要就是在屏幕中间展示 ‘Hello World’ . 1234567891011121314151617181920import 'package:flutter/material.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'Welcome to Flutter', home: new Scaffold( appBar: new AppBar( title: new Text('Welcome to Flutter'), ), body: new Center( child: new Text('Hello World'), ), ), ); &#125;&#125; 重新运行得到结果 发现 这个例子创建了一个 Material Design 风格的app . Material 是一种在移动端及web上标准的视觉设计语言 . Flutter 提供了丰富的 Material 风格小部件 main 方法使用了一个大箭头=&gt;写法 , 它是一行代码功能或方法的缩写 . 同许多语言开发一样, main() 方法为程序入口 . app 继承 StatefulWidget 使得其自身也是个widget . 在 Flutter 里 , 大多数元素都是 widget , 包括对齐方式(alignment)、 内边距(padding)、布局(layout) . Material 库 中的脚手架小部件 (Scaffold widget) , 提供了一个默认的导航栏、 标题、 内容属性在屏幕中维持了部件树🌲.部件子树可以很复杂. 一个小部件的主要工作就是提供 build()方法 , 它是用来表明如何展示其他低层级的widget. 这个示例的部件树由 包含一个 Text 子部件 的Center Widget 组成 . 这个 Center Widget 将其子部件树排列在屏幕中间 . 步骤 2 : 使用一个外部的程序包在这个步骤里 , 我们将开始使用一个开源程序包 english_words , 它包含了较多的常用的英文单词还有一些工具方法 . 我们可以在 pub.dartlang.org 找到 english_words 及 其他开源程序包 1. pubspec 文件负责管理 Flutter 应用的资源. 在 pubspec.yaml 文件中,添加 english_words(3.1.0或更高版本)到依赖里. 123456dependencies: flutter: sdk: flutter cupertino_icons: ^0.1.0 english_words: ^3.1.0 2. 当我们在IDEA 视图中 , 修改yaml文件后 , 可点击右上方的 Packages get 使之生效.它会拉取我们才添加的依赖包, 控制台中打印 123flutter packages getRunning "flutter packages get" in flutter_first_app...Process finished with exit code 0 3. 在 lib/main.dart文件中,添加 import 语句 , 导入依赖相关类 1import 'package:english_words/english_words.dart'; 4. 用开源库生成文本代替原来的 ‘Hello World’ 1234567891011121314151617181920212223import 'package:flutter/material.dart';import 'package:english_words/english_words.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; final wordPair = new WordPair.random(); return new MaterialApp( title: 'Welcome to Flutter', home: new Scaffold( appBar: new AppBar( title: new Text('Welcome to Flutter'), ), body: new Center( //child: new Text('Hello World'), // Replace the highlighted text... child: new Text(wordPair.asPascalCase), // With this highlighted text. ), ), ); &#125;&#125; 5. 若app正在运行, 可以通过点击⚡️按钮进行热部署. 每次点击或者保存时 , 会生成新的一个随机单词. 这是因为单词是在 build(...) 方法中生成, 它会在每次 MaterialApp 需要渲染或触发平台检视时执行. 步骤 3 : 增加一个 Stateful WidgetStateless widgets 是不可变的 , 意味着其属性是不可改变的 - 所有值均为final . Stateful widgets 维持着生命周期中可变的状态 . 实现一个 stateful widget 需要至少两个类: 一个 State 类 和 一个创建State示例的 StatefulWidget . StatefulWidget本身是不可变的 , 但是 State 类在widget生成周期中一直存留 . 在这个步骤里 , 我们将添加一个 stateful widget - RandomWords , 它创建自己的 State 类 - RandomWordsState . state 类将为widget最终维持建议的和喜好的单词. 1. 添加 stateful RandomWords 到 main.dart 1234class RandomWords extends StatefulWidget &#123; @override createState() =&gt; new RandomWordsState();&#125; 2. 添加 RandomWordsState . 大部分app的代码会在这个类中 , 将维持着 RandomWords 部件的状态 . 这个类将会保存生成的词对 , 它们随着用户滑动页面无线增加 . 然后喜好的词对 , 用户通过点击列表的心形按钮进行添加或移除 . 我们一步一步来创建这个类 12class RandomWordsState extends State&lt;RandomWords&gt; &#123;&#125; 3. 在添加 state 类后 , IDE会提示错误, 需要我们取实现未实现的方法 . 1234567class RandomWordsState extends State&lt;RandomWords&gt; &#123; @override Widget build(BuildContext context) &#123; final wordPair = new WordPair.random(); return new Text(wordPair.asPascalCase); &#125;&#125; 4. 移除单词生成代码 , 1234567891011121314151617class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'Welcome to Flutter', home: new Scaffold( appBar: new AppBar( title: new Text('Welcome to Flutter'), ), body: new Center( child: new RandomWords(), ), ), ); &#125;&#125; 步骤 4 : 创建一个无限滚动的 ListView这个步骤里, 我们将扩充 RandomWordsState 类 来生成和展示单词对的列表. 当用户滑动页面, ListView widget 展示的列表将会无限增加. ListView 的 builder 工厂构造器允许我们视需懒加载创建列表视图 1. 在 RandomWordsState 类中添加成员变量 _suggestions 列表用来保存推荐的单词对.在 Dart 语言中 , 以 _下划线开头的变量/方法为私有访问权限. 同样的 , 添加 biggerFont 变量用来使字体大小更大 123456class RandomWordsState extends State&lt;RandomWords&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _biggerFont = const TextStyle(fontSize: 18.0); ...&#125; 2 ~ 3. 添加 _buildSuggestions()方法到 RandomWordsState 类中. 此方法负责构建列表 ListView 和展示建议的单词对. ListView 类提供了一个 builder 属性 , itemBuilder 一个工厂构建者和指定匿名函数的回调功能.两个参数被传递给函数- BuildContext 还有行迭代器 i . 迭代器从 0 开始且每次方法调用递增. 添加 _buildRow 方法 123456789101112131415161718192021Widget _buildSuggestions() &#123; return new ListView.builder( // padding 16 padding: const EdgeInsets.all(16.0), // 每一对单词对调用一次itemBuilder 回调 ,然后放置一个推荐的单词对在行内 // 偶数行 , 函数增加个内容行显示单词对, // 奇数行 , 函数添加一条分割线小部件 (Divider Widget)去显示分割条目 itemBuilder: (context, i) &#123; if (i.isOdd) return new Divider(); // index 为 i/2 的余整数 final index = i ~/ 2; if (index &gt;= _suggestions.length) &#123; // ...生成10个词对,添加到list _suggestions.addAll(generateWordPairs().take(10)); &#125; return _buildRow(_suggestions[index]); &#125; ); &#125; 4. 更新 RandomWordsState 的 build 方法 , 使用 _buildSuggestions ,不再直接使用调用单词生产库. 12345678910111213class RandomWordsState extends State&lt;RandomWords&gt; &#123; ... @override Widget build(BuildContext context) &#123; return new Scaffold ( appBar: new AppBar( title: new Text('Startup Name Generator'), ), body: _buildSuggestions(), ); &#125; ...&#125; 5. 更新 MyApp 的 build 方法 . 从 MyApp 中移除 Scaffold 和 AppBar 实例. 这些将会被 RandomWordsState 管理 ,这样将更容易地在下个步骤页面跳转时去改变导航栏上的名称. 123456789class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'Startup Name Generator', home: new RandomWords(), ); &#125;&#125; 步骤 5 : 增加交互这个步骤中 , 我们将增加可点击的心形图标到每一行 . 当用户点击列表条目时 , 触发其 “favorite” 状态 ,状态改变会将对应单词对添加到保存的集合或从中移除 1. 添加 _saved 集合到 RandomWordsState 里 . 集合存储用户喜好的单词对 , 更倾向于用 Set 是因为 Set 中不允许有重复的条目 12345678class RandomWordsState extends State&lt;RandomWords&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _saved = new Set&lt;WordPair&gt;(); final _biggerFont = const TextStyle(fontSize: 18.0); ...&#125; 2. 在 _buildRow 函数里 , 添加 alreadySaved 变量来检查确保单词对还未被添加到喜好的集合中. 1234Widget _buildRow(WordPair pair) &#123; final alreadySaved = _saved.contains(pair); ...&#125; 3 ~ 4. 还是在_buildRow 里 , 添加心形图标 . 重启应用 , 我们可以看到心形已被添加 , 只是暂时没有交互事件 12345678910111213Widget _buildRow(WordPair pair) &#123; final alreadySaved = _saved.contains(pair); return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), trailing: new Icon( alreadySaved ? Icons.favorite : Icons.favorite_border, color: alreadySaved ? Colors.red : null, ), );&#125; 5. 在_buildRow 中设置心形可点击. 如果一个单词条目被添加到喜欢的集合时, 再次单击它就能从喜欢的集合中移除 . 当心形被点击 , 函数会调用 setState()去通知框架状态被改变了. 12345678910111213141516171819202122Widget _buildRow(WordPair pair) &#123; final alreadySaved = _saved.contains(pair); return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), trailing: new Icon( alreadySaved ? Icons.favorite : Icons.favorite_border, color: alreadySaved ? Colors.red : null, ), onTap: () &#123; setState(() &#123; if (alreadySaved) &#123; _saved.remove(pair); &#125; else &#123; _saved.add(pair); &#125; &#125;); &#125;, );&#125; 在 Flutter react式的框架中 , 调用 setState() 会为 State 对象触发 build() 方法 , 最后更新到UI上. 步骤 6 : 跳转到新页面在这个步骤里 , 我们将添加一个页面 (在Flutter里叫 route ) 展示喜好的推荐词对 . 我们将学到如何从主页面导航到新页面 . 在 Flutter 中 , Navigator 管理着一个包含app页面的栈 . 推送一个页面进入 Navigator 的栈中, 则会更新显示这个页面 . 从 Navigator栈中推出一个页面 , 则会显示上一个页面 . 1 ~ 3. 在 RandomWordsState 的 build 方法中给 AppBar 添加一个列表图标 . 当用户点击图标 , 一个包含喜好列表的页面会被推送呈现 . 12345678910111213141516class RandomWordsState extends State&lt;RandomWords&gt; &#123; ... @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text('Startup Name Generator'), actions: &lt;Widget&gt;[ new IconButton(icon: new Icon(Icons.list), onPressed: _pushSaved), ], ), body: _buildSuggestions(), ); &#125; ...&#125; 然后在 RandomWordsState 中添加 _pushSaved方法 12345class RandomWordsState extends State&lt;RandomWords&gt; &#123; ... void _pushSaved() &#123; &#125;&#125; 4 ~ 6. 添加 MaterialPageRoute 及它的 builder . 添加代码生成 ListTile 行 . ListTile 的divideTiles() 方法在每一条条目间增加水平距离 . divided 变量保存着最终的行 , 通过函数 toList() 转换为列表 builder 属性返回一个 Scaffold , 包含了新页面的导航栏 ,名为 “Saved Suggestion” .新页面的内容部分由 ListView包含 ListTiles 行组成 , 每一行由一个 divider 分隔 . 123456789101112131415161718192021222324void _pushSaved() &#123; Navigator.of(context).push( new MaterialPageRoute( builder: (context) &#123; final tiles = _saved.map( (pair) &#123; return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), ); &#125;, ); final divided = ListTile .divideTiles( context: context, tiles: tiles, ) .toList(); &#125;, ), );&#125; 步骤 7 : 通过主题改变UI在这个最终步骤中, 我们将改变app的主题 . 1. 我们可以简单地通过配置 ThemeData 类 改变app的主题 . 当前app是默认主题, 我们将改变主色为紫色 123456789101112class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'Startup Name Generator', home: new RandomWords(), theme: new ThemeData( primaryColor: Colors.purple ), ); &#125;&#125; 最后贴一下 main.dart 完整代码 , 方便小友们查看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123import 'package:flutter/material.dart';import 'package:english_words/english_words.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'Startup Name Generator', home: new RandomWords(), theme: new ThemeData(primaryColor: Colors.purple), ); &#125;&#125;class RandomWords extends StatefulWidget &#123; @override createState() =&gt; new RandomWordsState();&#125;class RandomWordsState extends State&lt;RandomWords&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _saved = new Set&lt;WordPair&gt;(); final _biggerFont = const TextStyle(fontSize: 18.0); Widget _buildSuggestions() &#123; return new ListView.builder( // padding 16 padding: const EdgeInsets.all(16.0), // 每一对单词对调用一次itemBuilder 回调 ,然后放置一个推荐的单词对在行内 // 偶数行 , 函数增加个内容行显示单词对, // 奇数行 , 函数添加一条分割线小部件 (Divider Widget)去显示分割条目 itemBuilder: (context, i) &#123; if (i.isOdd) return new Divider(); // index 为 i/2 的余整数 final index = i ~/ 2; if (index &gt;= _suggestions.length) &#123; // ...生成10个词对,添加到list _suggestions.addAll(generateWordPairs().take(10)); &#125; return _buildRow(_suggestions[index]); &#125;); &#125; Widget _buildRow(WordPair pair) &#123; final alreadySaved = _saved.contains(pair); return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), trailing: new Icon( alreadySaved ? Icons.favorite : Icons.favorite_border, color: alreadySaved ? Colors.red : null, ), onTap: () &#123; setState(() &#123; if (alreadySaved) &#123; _saved.remove(pair); &#125; else &#123; _saved.add(pair); &#125; &#125;); &#125;, ); &#125; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text('Startup Name Generator'), actions: &lt;Widget&gt;[// new IconButton(icon: new Icon(Icons.colorize),onPressed: _changeTheme), new IconButton(icon: new Icon(Icons.list), onPressed: _pushSaved) ], ), body: _buildSuggestions(), ); &#125; void _changeTheme()&#123; &#125; void _pushSaved() &#123; Navigator.of(context).push( new MaterialPageRoute( builder: (context) &#123; final tiles = _saved.map( (pair) &#123; return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), ); &#125;, ); final divided = ListTile .divideTiles( context: context, tiles: tiles, ) .toList(); return new Scaffold( appBar: new AppBar( title: new Text('Saved Suggestions'), ), body: new ListView(children: divided), ); &#125;, ), ); &#125;&#125; 完成!至此 , 我们第一个 app 已经完成 . GitHub 地址 功能相对来说较简单 , 但是大体上让我们对开发 Flutter app 有了一定了解. 之后我们将延续阅读官网的教程 , 开始较全面地了解构建UI相关的部分.]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter基础-(1)环境搭建及demo运行]]></title>
    <url>%2Fflutter-basic-env%2F</url>
    <content type="text"><![CDATA[Flutter 是一款谷歌用以同时在 iOS 和 Android 上制作高质量原生界面的移动应用UI框架.目前谷歌是已发布了 Flutter Beta 版,同时也提供了多个 Sample Project 供学习. Flutter 主要有着快速开发、有表现力及灵活的UI、原生表现等特点. 快速开发 极速热部署就能使app构建生效,使用大量可深度自定义化的小部件 (Widgets) 供快速开发原生界面. 有表现力及灵活的UI 快速地将特性集中在客户端用户体验上.分层体系结构允许深度定制,最终呈现快速渲染以及有表现力和灵活的设计 原生表现 Flutter的小部件包含了所有关键的平台差异,如滚动、导航、图标和字体,以在iOS和Android上提供完整的原生表现 类似于 Fackbook 的 React Native , 我们可用 Flutter 开发一套代码,应用于 Android 以及 iOS 平台上.不仅如此, Flutter 还可应用于谷歌将推出的新系统 Fuchsia . 可以看出 , Flutter 确有统一移动端的能力 , 身为移动开发者 , 当然要有所了解. so , 接下来我们将开始 搭建开发环境 , 并且运行官方的 demo 为了更好的阅读体验, 请点击阅读原文 :) 安装首先进入 Flutter Install 选择相应操作系统下的安装包进行安装 首先此处有个温馨小点 , 谷歌为中国开发者准备了国内镜像,为图中的链接 this wiki article . 主要是配置两个环境变量 PUB_HOSTED_URL 和 FLUTTER_STORAGE_BASE_URL , 安装时当检测到有这俩环境变量,就会优先读取变量存储的地址去安装. 创建或者打开 $HOME/.bash_profile , 在下方添加两行变量 12export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 然后 source $HOME/.bash_profile 使之在当前 terminal 生效. 最后可用 echo $PUB_HOSTED_URL 和 echo $FLUTTER_STORAGE_BASE_URL 检测是否添加成功 最好配置下这个地址.笔者尝试数次,科学上网期间但没配置这倆地址时,下载组件时总会崩溃中断 😧. 此处我们选择 macOS ,其他系统下的安装可自行参考谷歌文档. 系统要求想要安装并运行 Flutter , 开发环境必须满足最低要求: 操作系统 : macOS (64位) 磁盘空间 : 700 MB (不包含 Xcode 或 Android Studio的空间) 工具 : Flutter 依赖于这些系统环境里的命令行工具 bash , mkdir , rm , git , curl , unzip , which 获取 Flutter SDK使用 git 命令克隆库并且添加 flutter 工具到环境变量中. 运行 flutter doctor 会显示剩余需要去安装的依赖. 克隆仓库当前我们需要克隆仓库beta分支 , 然后添加环境变量 12git clone -b beta https://github.com/flutter/flutter.gitexport PATH=`pwd`/flutter/bin:$PATH 以上命令只是设置临时变量,建议将其永久添加到环境变量中. 创建或打开 $HOME/.bash_profile 文件. 添加以下行,并且替换 [PATH_TO_FLUTTER_GIT_DIRECTORY] 为你的 Flutter git目录 1export PATH=[PATH_TO_FLUTTER_GIT_DIRECTORY]/flutter/bin:$PATH 然后运行 source $HOME/.bash_profile 使之在当前 terminal 生效. 可用 echo $PATH 检测是否添加成功 检测依赖运行以下命令来检测必要依赖是否已经完成安装 1flutter doctor 这个命令检测环境然后将结果显示在命令行窗口. Dart SDK 与 Flutter 绑定在一起 , 没必要单独安装 Dart. 仔细检查结果,可能需要安装依赖或者执行任务 (粗体显示) eg. 12345[-] Android toolchain - develop for Android devices • Android SDK at /Users/obiwan/Library/Android/sdk ✗ Android SDK is missing command line tools; download from https://goo.gl/XxQghQ • Try re-installing or updating your Android SDK, visit https://flutter.io/setup/#android-setup for detailed instructions. 第一次运行 flutter 命令 如( flutter doctor ), 会自行开始下载依赖库并编译. 后续的运行就会变的快的多. Flutter 使用 Google Analytics 来匿名报告功能使用统计以及崩溃日志, 可通过 flutter config --no-analytics 来禁用报告. 这里说句题外话 , 几年前谣传谷歌要采用新的 Android 开发语言 Sky 代替 Java . 后面沉溺了一段时间 , 最终它还是被谷歌发布出来了,只不过现在叫 Flutter . 但不难发现 , Flutter中多少还是有易容前的的影子,比如上图中第二个加载的包就叫 sky_engine .. 编辑器设置环境搭建好了 , 开始选择编辑器了. 建议的编辑器有 Android Studio , IntelliJ IDEA , VS Code等. Android Studio 需要 3.0 或以上的版本 IntelliJ IDEA 需要 2017.1 或之后的版本 VS Code 需要 1.20 或以上的版本 这里我们选择 IntelliJ IDEA 来作为编辑器并且安装 Flutter , Dart 两款插件 , 安装步骤主要为 开启 IntelliJ IDEA 打开插件偏好设置 (macOS上为Preferences&gt;Plugins , Windows及Linux上为File&gt;Settings&gt;Plugins) 选择 Browse repositories… , 输入 Flutter 然后点击 install 安装 点击 Yes 当提示去安装 Dart Plugin 安装完成后重启 IDEA Android Studio 安装插件与 IntelliJ IDEA一致 , VS Code 的请参考官网 Editor 平台设置macOS 支持开发 Android 及 iOS Flutter apps .完成其中一个平台的设置即可编译和运行 Flutter app . iOS 设置安装 Xcode我们需要安装 Xcode 7.2 或以上版本 , 整体步骤为: 安装 Xcode 7.2 或以上的版本 (通过 web 或者 Mac AppStore) 命令行运行 sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer 配置 Xcode命令行工具以使用新安装的 Xcode 版本 确认 Xcode license 协议被签署过. 可通过打开一次 Xcode 或命令行运行 sudo xcodebuild -license 使用 Xcode 我们就能在 iOS 设备或模拟器上运行 Flutter apps 设置iOS模拟器 首先打开模拟器 通过命令 open -a Simulator 或者 Spotlight 通过检查模拟器的 Hardware &gt; Device 菜单中得设置 , 以确保模拟器正在使用64位设备 (iPhone 5s或更高版本) 取决于开发设备屏幕尺寸 , 高屏幕密度的iOS模拟设备可能会在屏幕上溢出 , 在模拟器的Window &gt; Scale菜单下设置设备比例 通过运行 flutter run 来启动应用 部署到iOS设备要部署 Flutter app 到 iOS设备 , 我们需要一些额外的工具和 Apple 账号 . 还需要在设备上进行设置 安装 homebrew 打开命令终端运行以下命令以安装工具 1234brew updatebrew install --HEAD libimobiledevicebrew install ideviceinstaller ios-deploy cocoapodspod setup 如若这些命令出现异常失败了, 运行 brew doctor 按照说明解决问题 然后依照 Xcode 签名流程来配置项目 从Flutter项目目录中的终端窗口中运行ios/Runner.xcworkspace来打开Xcode工作空间 , 也可直接双击文件打开 在Xcode中,从左侧导航面板中选择 Runner 项目 Runner target设置页面 , 确保在General &gt; Signing &gt; Team下的开发团队是被选中的. 当选择一个团队 , Xcode会创建并下载开发证书 , 并账号中注册此设备 , 然后创建并下载一个描述文件. 如果是第一个iOS开发项目,则可能需要使用到 Apple ID 登录Xcode 当第一次使用设备进行iOS开发时, 需要在设备上信任Mac和开发证书.首次将iOS设备连接到Mac时,会弹出一个对话框,在对话框中点击信任即可. 然后去 iOS 设备上设置应用程序 , General &gt; Device Management下选择信任你的证书 若 Xcode中的自动签名失败 , 请验证项目中的General&gt; Identity&gt; Bundle Identifier下的值是否唯一 然后可通过 flutter run 运行app Android 设置安装 Android Studio我们需要安装并配置 Android Studio , 整体步骤为: 下载并安装 Android Studio 打开 Android Studio , 走完 ‘Android Studio 安装指南’ . 这将安装最新的 Android SDK, Android SDK Platform-Tools, and Android SDK Build-Tools , 这是 Flutter 开发 Android 必要的. 设置Android模拟器运行模拟器比较吃资源 , 这里建议还是使用Android真机. 如若需要配置模拟器请参考官网 设置Android设备要运行并且测试我们的应用在 Android 设备上 , 我们需要系统版本为 Android 4.1 及以上的 Android 设备 打开 开发者选项 还有 USB调试 . 使用USB将手机连接电脑 . 若手机出现提示,授权电脑访问手机 在命令执行 flutter devices 确认连接电脑的设备 然后可通过执行 flutter run 运行我们的app 这里的 flutter devices 命令类似 adb 的 adb devices . 如若提示不可用 , 请将 adb 所在目录添加到环境变量 . 运行app命令终端首先用 flutter create 命令创建新项目 12flutter create myappcd myapp 以上命令创建了一个 名为 myapp 的 Flutter 项目 , 其为一个包含 Material Components 的简单demo . 项目目录里 , app的代码在 lib/main.dart 中. 然后运行app 确保有设备已经连接 , 若无设备连接,请参考文中 平台设置 1flutter devices 通过 flutter run 命令运行app 1flutter run 若不出意外,则运行成功 尝试热部署 . Flutter 提供了热部署以供快速开发. 打开 lib/main.dart 修改界面文案,保存 在命令终端按下 ‘r’ 界面文案即刻更新生效 Android StudioIntelliJ IDEA 和 Android Studio 对热更新操作更便捷. 同样是在运行后,修改文案保存,然后点击闪电⚡️Reload即可 这里吐槽下, 首次运行 iOS 比 Android 要快不要太多. 主要是 Gradle构建的问题 . on Android : on iOS : 运行官方Demo创建的默认项目功能较简单,不能够给我们带来较深刻的体验. 我们可以参考 Flutter Demo . 这里我们拿其中较不错的 flutter_gallery 来运行. 首先下载下来,进入其目录. 这里因为demo运行需要安装额外依赖,所以需要对终端/IDEA 进行科学上网配置.不清楚的请根据自身科学上网姿势配置 :) 然后运行 flutter doctor ,如果是IDEA打开则直接自动运行 , 可能得到这结果. 此时打开项目目录中的 pubspec.yaml 找到 test: 0.12.30+4 改为 test: 0.12.30+3 即可 Flutter是一个初期的开源项目，它帮助开发者从一个代码库构建出高性能、高保真度的移动应用 . 这个Gallery是Flutter的许多小部件、行为、动画、布局等的预览 . 正如 Flutter Gallery 官方介绍所说 , 它主要呈现的是一些小部件的预览 , 主题皮肤切换 , 控件风格切换等示例 . 后期的学习中可参考其进行.]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ+Gradle自定义war包名称]]></title>
    <url>%2Fidea-gradle_war%2F</url>
    <content type="text"><![CDATA[最近在帮朋友开发小程序的 Java 后端,项目采用 Gradle 构建,使用IntelliJ开发. 开发中经常需要发包到外网上,方便前端联调,而IntelliJ默认构建的 war 包名称为项目名-版本号,使得每次上传war包至服务器tomcat时还得手动重命名,发布次数多了,就显得很繁琐.这里就水一篇,简短说明下 IntelliJ中Gradle构建如何自定义war包名称. 首先打开 Project Settings 选择 Artifacts 前两个 Gradle:xxx 是创建Gradle项目并添加tomcat后,自动生成的.我们这里点击 + 新增 选择 Web Application: Archive -&gt; Empty 修改war包名称及输出路径 添加war包内容,同样选择 Artifact 选择 Gradle: xxx (exploded) 之后打包只能选择 Build -&gt; Build Artifacts 然后选择自定义的build, 然后在输出目录下即可找到war包]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IntelliJ</tag>
        <tag>war</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo绑定自定义Https域名]]></title>
    <url>%2Fhexo_ssl_netlify%2F</url>
    <content type="text"><![CDATA[通常我们将Hexo博客部署到GitHub Pages上,然后绑定自定义域名.例如作者的 GitHub Page lhalcyon.github.io绑定到了lhalcyon.com上.但是 GitHub Pages 无法给自定义域名配置SSL GitHub Pages默认是支持https的,即我们可通常https://lhalcyon.github.io来访问博客,但是绑定自定义域名后,只能通过http://lhalcyon.com正常访问,如直接访问https://lhalcyon.com就会爆红 由于博客已改造完成,就度娘了张示例图 为了实现自定义域名SSL认证,通常的做法是在Cloudflare配置一个反向代理到GitHub Pages,但是其访问速度及稳定性不太好,再就是博客更新后生效也会有延迟,于是我们得寻索一个解决办法. 为了更好的阅读体验,请点击阅读原文😉. 起初是考虑将Hexo迁移到Coding Pages上,后来发现其免费托管下必须在首页对其做一个广告,否则访问会先跳转到一个中转广告页再进行跳转 ,想免广告只能升级黄金会员及以上,这点太不友好. 问题传送门 跳转页: or 主动添加广告链接,审核过后会免去跳转页 某博客页脚添加的广告: 无疑这样大大影响我们的博客美观,不能接受,但又不想迁回GitHub Pages,怎么办?下面我们介绍一些免费及好用的静态网站托管平台 免费静态网站托管平台GitHub Pages优点 自带域名可https访问 可配置自定义域名 缺点 无法给自定义域名配置SSL Bitbucket Cloud跟 GitHub Pages 功能一样,但是: 无法自定义域名 能且只能通过 https 协议访问（http 协议会被跳转到 https 协议) 所有项目的静态网站代码都只能放在专门的站点仓库里（accountName.bitbucket.io) ,不能像 GitHub 那样可以在每个项目里用 gh-pages 分支保存文件 aerobaticBitbucket 旗下的静态网站托管服务. 可以使用 CLI 上传代码 支持自动构建 (Continuous Deployment) 可以自定义域名但是收费功能,自定义域名支持 https 且不需要提供证书,它会帮你生成一个 GitLab Pages同样和 GitHub Pages 的功能一样,但是: 自定义域名可配置https,不过需要上传证书 surge.sh 只能使用 CLI 上传代码 支持自定义域名,但开启 SSL 是收费功能且需要自行上传证书 支持200.html —— 适用于使用 History API 的 SPA Firebase Hosting 只能使用 CLI 上传代码 支持自定义域名并支持一键开启 https 支持重定向（Redirects）和重写（Rewrites）功能（当网站使用 History API 时特别有用) but 有被墙的风险…… Netlify (推荐) 可以使用 CLI 上传代码 支持自定义域名且自定义域名支持一键开启 https（证书来自 Let’s Encrype） 支持强制让用户通过 https 访问网站（开启后此功能后，http 的访问一律会 301 跳转到 https 支持自动构建 支持重定向（Redirects）和重写（Rewrites）功能 数据通过 HTTP2 协议传输 提供 webhooks 与 API now 可以使用 CLI 上传代码，或者链接一个 Git 仓库 不仅提供静态网站托管，同时也支持托管 Node.js 服务 支持自定义域名且自定义域名支持一键开启 https（证书来自 Let’s Encrype） 数据通过 HTTP2 协议传输 提供 API Coding Pages上面我们说过,收费机制甚不友好 鉴于各平台特点,我们选择Netlify Netlify部署网站首先去 Netlify 注册账号登录 接着点击页面右上角的 New site from Git 这里选择的 GitHub ,别忘记勾选访问公共仓库选项.之后授权给 Netlify 指定Repository,然后 Deploy 设置自定义域名点击 Domain settings 然后点击 Add custom domain. 然后到域名解析处,修改域名CNAME记录,记录值就是设置完域名页面显示的配置值 添加SSL证书设置完成域名绑定后,设置中心选项有所变化,增加了一个 Enable HTTPS的选项 , 点击 点击 Let’s Encrypt Certificate, 系统会自动签发证书给站点,若域名解析没问题就能签发成功 若想一直使用Https访问的话,就勾选 Force TLS connections 强制所有访问转换为Https 至此,配置全部完成 后续Netlify 还有很多技巧,比如可以设置变量及命令.免费用户可以为网站设置变量、webhook等.付费用户则可以为网站设置更加详细的SEO优化.各位可以自行去挖掘~ 🧐 参考: https://github.com/lmk123/blog/issues/55]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>SSL</tag>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC+WebSocket+Gradle实现消息实时推送]]></title>
    <url>%2Fspringmvc-websocket_im%2F</url>
    <content type="text"><![CDATA[WebSocket是HTML5开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。 WebSocket通信协议于2011年被IETF定为标准RFC 6455，WebSocketAPI被W3C定为标准。 在WebSocket API中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。 以上摘自Wikipedia. 本文将说明在Intellij IDEA下使用Gradle构建SpringMVC+WebSocket实现消息推送.为了更好的阅读体验,请点击阅读原文😉. 创建项目在之前的文章中有详细的说明,此篇不做赘述.可参考IDEA+Gradle创建MyBatis+SpringMVC项目 导入依赖在build.gradle中导入denpendies 12345678910111213// ------------------------ Spring SpringMVC start -------------------------compile group: 'org.springframework', name: 'spring-webmvc', version: '4.2.4.RELEASE'compile group: 'org.springframework', name: 'spring-context-support', version: '4.2.4.RELEASE'// ------------------------ Spring SpringMVC end -------------------------// ------------------------ WebSocket start -------------------------compile group: 'org.springframework', name: 'spring-websocket', version: '4.2.4.RELEASE'compile group: 'org.springframework', name: 'spring-messaging', version: '4.2.4.RELEASE'compile group: 'javax.servlet', name: 'javax.servlet-api', version: '3.1.0'// ------------------------ WebSocket end -------------------------compile group: 'log4j', name: 'log4j', version: '1.2.17'compile group: 'com.google.code.gson', name: 'gson', version: '2.8.2' 此处需要注意的是Spring从4.0+版本开始支持WebSocket,而servlet-api需要为3.0+版本 配置文件web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt; &lt;!-- 初始化spring 容器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring/applicationContext-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;index-dispather&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:config/spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;index-dispather&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 解决post乱码问题 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; 此处需要给servlet及filter添加异步&lt;async-supported&gt;true&lt;/async-supported&gt;. spring-mvc.xml 123456789101112131415161718192021222324252627&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 自动扫描控制器,webSocket --&gt; &lt;context:component-scan base-package="com.lhalcyon.king.controller,com.lhalcyon.king.socket"/&gt; &lt;!-- 视图渲染 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/views/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;!-- 控制器映射器和控制器适配器 --&gt; &lt;mvc:annotation-driven&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 静态资源映射器 --&gt; &lt;mvc:resources mapping="/statics/**" location="/WEB-INF/statics/" /&gt;&lt;/beans&gt; 此处需配置扫描controller和websocket所在包 还有一个applicationContext-websocket.xml配置文件我们在代码实现中说明 代码实现握手拦截器HandshakeInterceptor 拦截器说明 An interceptor to copy information from the HTTP session to the “handshakeattributes” map to made available via WebSocketSession.getAttributes()Copies a subset or all HTTP session attributes and/or the HTTP session id 拦截器主要用于用户登录标识的记录,便于后面获取指定用户的会话标识并向指定用户发送消息, 这里我们继承HttpSessionHandshakeInterceptor 123456789101112131415161718192021222324public class HandshakeInterceptor extends HttpSessionHandshakeInterceptor &#123; private Logger logger = Logger.getLogger(HandshakeInterceptor.class); // 握手前 @Override public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes) throws Exception &#123; logger.info("++ HandshakeInterceptor: beforeHandshake ++"+attributes); return super.beforeHandshake(request, response, wsHandler, attributes); &#125; // 握手后 @Override public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception ex) &#123; logger.info("++ HandshakeInterceptor: afterHandshake ++"); super.afterHandshake(request, response, wsHandler, ex); &#125;&#125; beforeHandshake(..) Invoked before the handshake is processed. afterHandshake(..) Invoked after the handshake is done. The response status and headers indicate the results of the handshake, i.e. whether it was successful or not. 两个方法调用时机均为字面所述,握手前后分别调用.主要是在握手前后去做一些事,比如将需要的数据设置到attributes里,之后在WebSocketHandler的session中获取这些数据. 处理类WebSocketHandler 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class MyWebSocketHandler implements WebSocketHandler &#123; private static final Logger log = Logger.getLogger(MyWebSocketHandler.class); // 保存所有的用户session private static final ArrayList&lt;WebSocketSession&gt; users = new ArrayList&lt;WebSocketSession&gt;(); @Override public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123; log.info("connect websocket success......."); users.add(session); &#125; @Override public void handleMessage(WebSocketSession session, WebSocketMessage&lt;?&gt; message) throws Exception &#123; Gson gson = new Gson(); // 将消息JSON格式通过Gson转换成Map // message.getPayload().toString() 获取消息具体内容 Map&lt;String, Object&gt; msg = gson.fromJson(message.getPayload().toString(), new TypeToken&lt;Map&lt;String, Object&gt;&gt;() &#123;&#125;.getType()); log.info("handleMessage......."+message.getPayload()+"..........."+msg); String content = message.getPayload().toString(); // 处理消息 msgContent消息内容 TextMessage textMessage = new TextMessage(content, true); // 调用方法（发送消息给所有人） sendMsgToAllUsers(textMessage); &#125; @Override public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception &#123; log.warn("handleTransportError"); users.remove(session); &#125; @Override public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception &#123; log.info("connect websocket closed......."); users.remove(session); &#125; // 给所有用户发送 信息 public void sendMsgToAllUsers(WebSocketMessage&lt;?&gt; message) throws Exception&#123; for (WebSocketSession user : users) &#123; user.sendMessage(message); &#125; &#125; @Override public boolean supportsPartialMessages() &#123; return false; &#125;&#125; 以下对主要方法进行说明: afterConnectionEstablished(..) 连接建立后调用,常用于记录用户的连接标识,便于后面信息发送. handleTextMessage(..) 对消息进行处理. handleTransportError(..) 连接异常处理.需要关闭出错会话连接 afterConnectionClosed(..) 连接关闭处理 此处我们对消息的处理很简单,即在接受消息后发送给所有连接的用户,类似一个匿名群聊室. 注册完成了WebSocket处理类,还需要对其进行注册生效.这里有两种方式,择其一即可. 创建配置类,并通过注解注册123456789101112131415161718192021@Configuration@EnableWebMvc@EnableWebSocketpublic class MyWebSocketConfig extends WebMvcConfigurerAdapter implements WebSocketConfigurer &#123; @Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123; //前台 可以使用websocket环境 registry.addHandler(myWebSocketHandler(),"/websocket").addInterceptors(new HandshakeInterceptor()).setAllowedOrigins("*"); //前台 不可以使用websocket环境，则使用sockjs进行模拟连接 registry.addHandler(myWebSocketHandler(), "/sockjs/websocket").addInterceptors(new HandshakeInterceptor()) .withSockJS(); &#125; // websocket 处理类 @Bean public WebSocketHandler myWebSocketHandler()&#123; return new MyWebSocketHandler(); &#125;&#125; 同时还需要配置上文提到过的Spring扫描配置类. 12&lt;!-- 自动扫描控制器,webSocket --&gt;&lt;context:component-scan base-package="com.lhalcyon.king.controller,com.lhalcyon.king.socket"/&gt; 通过xml配置注册applicationContext-websocket.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:websocket="http://www.springframework.org/schema/websocket" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/websocket http://www.springframework.org/schema/websocket/spring-websocket-4.0.xsd"&gt; &lt;!-- websocket处理类 --&gt; &lt;bean id="myHandler" class="com.lhalcyon.king.socket.MyWebSocketHandler"/&gt; &lt;!-- 握手接口/拦截器 --&gt; &lt;bean id="myInterceptor" class="com.lhalcyon.king.socket.HandshakeInterceptor"/&gt; &lt;websocket:handlers&gt; &lt;websocket:mapping path="/websocket" handler="myHandler"/&gt; &lt;websocket:handshake-interceptors&gt; &lt;ref bean="myInterceptor"/&gt; &lt;/websocket:handshake-interceptors&gt; &lt;/websocket:handlers&gt; &lt;!-- 注册 sockJS --&gt; &lt;websocket:handlers&gt; &lt;websocket:mapping path="/websocket" handler="myHandler"/&gt; &lt;websocket:handshake-interceptors&gt; &lt;ref bean="myInterceptor"/&gt; &lt;/websocket:handshake-interceptors&gt; &lt;websocket:sockjs /&gt; &lt;/websocket:handlers&gt;&lt;/beans&gt; 以上服务端代码实现基本完成,接下来对客户端测试页面做一个简单的实现. 客户端页面index.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;首页&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta name="renderer" content="webkit"&gt; &lt;!-- 引入 JQuery --&gt; &lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- 引入 sockJS --&gt; &lt;script type="text/javascript" src="https://cdn.bootcss.com/sockjs-client/1.1.4/sockjs.min.js" &gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function() &#123; var websocket; // 首先判断是否 支持 WebSocket var url = 'ws://' + window.location.host + '/word-king/websocket'; if('WebSocket' in window) &#123; websocket = new WebSocket(url); &#125; else if('MozWebSocket' in window) &#123; websocket = new MozWebSocket(url); &#125; else &#123; url = "http://"+ window.location.host +"/word-king/sockjs/websocket"; websocket = new SockJS(url); &#125; // 打开时 websocket.onopen = function(evnt) &#123; console.log(" websocket.onopen "); &#125;; // 处理消息时 websocket.onmessage = function(evnt) &#123; $("#msg").append("&lt;p&gt;(&lt;font color='red'&gt;" + evnt.data + "&lt;/font&gt;)&lt;/p&gt;"); console.log(" websocket.onmessage "); &#125;; websocket.onerror = function(evnt) &#123; alert("onerror"); console.log(" websocket.onerror "); &#125;; websocket.onclose = function(evnt) &#123; console.log(" websocket.onclose "); alert("onclose"); &#125;; // 点击了发送消息按钮的响应事件 $("#TXBTN").click(function()&#123; // 获取消息内容 var text = $("#tx").val(); // 判断 if(text == null || text == "")&#123; alert(" content can not empty!!"); return false; &#125; var msg = &#123; msgContent: text, postsId: 1 &#125;; // 发送消息 websocket.send(JSON.stringify(msg)); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 最外边框 --&gt;&lt;div style="margin: 20px auto; border: 1px solid blue; width: 300px; height: 500px;"&gt; &lt;!-- 消息展示框 --&gt; &lt;div id="msg" style="width: 100%; height: 70%; border: 1px solid yellow;overflow: auto;"&gt;&lt;/div&gt; &lt;!-- 消息编辑框 --&gt; &lt;textarea id="tx" style="width: 100%; height: 20%;"&gt;&lt;/textarea&gt; &lt;!-- 消息发送按钮 --&gt; &lt;button id="TXBTN" style="width: 100%; height: 8%;"&gt;发送数据&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 需要注意的是此处引入JQuery时,如果是本地的文件,可能存在无效的情况,需要去设置静态资源映射路径,可自行🔍解决. 本文采用的是引入在线地址 12&lt;!-- 引入 JQuery --&gt; &lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.5/jquery.min.js"&gt;&lt;/script&gt; 地址写入后需Download下来 代码不高亮警告后即能生效. 最后我们来看看效果 参考: http://blog.csdn.net/mybook201314/article/details/70173674]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>WebSocket</tag>
        <tag>IM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现apk上传蒲公英后自动发送钉钉通知]]></title>
    <url>%2Fwebhook_dingding-pgyer%2F</url>
    <content type="text"><![CDATA[Webhook是一个API概念，并且变得越来越流行。我们能用事件描述的事物越多，webhook的作用范围也就越大。Webhook作为一个轻量的事件处理应用，正变得越来越有用。 准确的说webhook是一种web回调或者http的push API，是向APP或者其他应用提供实时信息的一种方式。Webhook在数据产生时立即发送数据，也就是你能实时收到数据。这一种不同于典型的API，需要用了实时性需要足够快的轮询。这无论是对生产还是对消费者都是高效的，唯一的缺点是初始建立困难。 Webhook有时也被称为反向API，因为他提供了API规则，你需要设计要使用的API。Webhook将向你的应用发起http请求，典型的是post请求，应用程序由请求驱动。 在Android开发中会经常提交apk给测试人员进行测试,通常的做法是将构建完成的包上传至蒲公英,测试人员直接扫码下载并安装apk包从而进行测试.一般我们会将构建及发布过程自动化,可参考: Linux+Jenkins+Gradle构建Android参数化自动打包(一) Linux+Jenkins+Gradle构建Android参数化自动打包(二) 文章中实现了apk上传蒲公英后邮件通知,可是实际中,大家对邮件的关注远远没有对IM消息的关注度高,所以接下来本文将说明,实现上传apk后自动发送钉钉消息,将更新内容,apk版本号等信息通知到测试人员 环境准备首先环境搭建是IntelliJ+SpringMVC+Gradle构建的,如有疑问的同学可参考IDEA+Gradle创建MyBatis+SpringMVC项目,项目中主要是对接口数据的调整及转发,实际上未用到MyBatis,可自行进行去除🙄. 模型建立对照蒲公英doc、钉钉doc分别建立Java Bean. PgyerMessage 123456789101112131415&#123; "action": "应用更新", "title": "OooPlay", "link": "https://www.pgyer.com/oooplay_test", "message": "您的应用OooPlay有了新的版本(2.4)更新。", "type": "updateVersion", "os_version": "2.4", "build_version": "139", "created": "2015-10-09 11:25:16", "updated": "2015-10-09 11:25:16", "timestamp": 1444361118, "appsize": "2238036", "device_type": 'iOS', "notes": "修复了一些小弱智的小bug"&#125; 1234567891011121314151617181920212223242526272829303132333435public class PgyerMessage &#123; public String action; public String title; public String link; public String message; public String type; public String os_version; public String build_version; public String created; public String updated; public int timestamp; public String appsize; public String device_type; public String notes; @Override public String toString() &#123; return "PgyerMessage&#123;" + "action='" + action + '\'' + ", title='" + title + '\'' + ", link='" + link + '\'' + ", message='" + message + '\'' + ", type='" + type + '\'' + ", os_version='" + os_version + '\'' + ", build_version='" + build_version + '\'' + ", created='" + created + '\'' + ", updated='" + updated + '\'' + ", timestamp=" + timestamp + ", appsize='" + appsize + '\'' + ", device_type='" + device_type + '\'' + ", notes='" + notes + '\'' + '&#125;'; &#125;&#125; 此处有个小技巧,IDEA IntelliJ有个好用的插件GsonFormat可一键将Json字符串转换为Java Model 钉钉消息则分为几种类型,具体举例可参考钉钉doc 123456789public static final String TYPE_LINK = "link";public static final String TYPE_MARKDOWN = "markdown";public static final String TYPE_TEXT = "text";public static final String TYPE_ACTIONCARD = "actionCard";public static final String TYPE_FEEDCARD = "feedCard"; 此处我们选择markdown类型.为了便于拓展,此处将消息抽取了个基类BaseDingMessage. 123456789101112131415161718192021public class BaseDingMessage &#123; public static final String TYPE_LINK = "link"; public static final String TYPE_MARKDOWN = "markdown"; public static final String TYPE_TEXT = "text"; public static final String TYPE_ACTIONCARD = "actionCard"; public static final String TYPE_FEEDCARD = "feedCard"; public String msgtype; public AtBean at; public static class AtBean &#123; public boolean isAtAll; public List&lt;String&gt; atMobiles; &#125;&#125; 12345678910public class MarkdownMessage extends BaseDingMessage &#123; public MarkdownBean markdown; public static class MarkdownBean &#123; public String title; public String text; &#125;&#125; 代码实现首先在build.gradle中导入依赖 12compile group: 'com.alibaba', name: 'fastjson', version: '1.2.45'compile group: 'com.squareup.okhttp3', name: 'okhttp', version: '3.9.0' fastjson是用力啊转化json,okhttp用来网络请求 spring-mvc.xml加入json配置 12345678910111213141516171819202122232425262728293031323334353637&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 自动扫描控制器 --&gt; &lt;context:component-scan base-package="com.lhalcyon.webhook.controller"/&gt; &lt;!-- 视图渲染 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/views/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;!-- 控制器映射器和控制器适配器 --&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults="true"&gt; &lt;bean class="com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;value&gt;application/json&lt;/value&gt; &lt;value&gt;application/xml;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 静态资源映射器 --&gt; &lt;mvc:resources mapping="/statics/**" location="/WEB-INF/statics/" /&gt;&lt;/beans&gt; 消息发送服务DingServiceImpl.java 123456789101112131415161718192021Servicepublic class DingServiceImpl implements DingService &#123; private static final Logger logger = Logger.getLogger(DingServiceImpl.class); @Override public void send(BaseDingMessage message,String url) &#123; MediaType jsonType = MediaType.parse("application/json; charset=utf-8"); okhttp3.RequestBody body = okhttp3.RequestBody.create(jsonType, JSON.toJSONString(message)); final Request request = new Request.Builder() .url(url) .post(body) .build(); OkHttpClient client = OkhttpProvider.get(); try &#123; client.newCall(request).execute(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 蒲公英请求控制器PgyerController.java 123456789101112131415161718@RestController@RequestMapping("/pgyer")public class PgyerController &#123; @Autowired DingService dingService; private static final Logger logger = Logger.getLogger(PgyerController.class); @ResponseBody @RequestMapping(value = "/update",method = RequestMethod.POST) public BaseDingMessage apkUpdate(@RequestBody PgyerMessage pgyerMessage)&#123; BaseDingMessage dingMessage = WebhookConverter.pgyer2Ding(pgyerMessage); dingService.send(dingMessage, Urls.DING_TEST); logger.info(dingMessage); return dingMessage; &#125;&#125; 其中Urls.DING_TEST为钉钉机器人的会话token地址,后面会说明如何创建/获取 消息转换器WebhookConverter.java 123456789101112131415161718192021222324public class WebhookConverter &#123; private static final Logger logger = Logger.getLogger(WebhookConverter.class); public static MarkdownMessage pgyer2Ding(PgyerMessage pgyerMessage)&#123; MarkdownMessage message = new MarkdownMessage(); message.msgtype = BaseDingMessage.TYPE_MARKDOWN; message.markdown = new MarkdownMessage.MarkdownBean(); message.markdown.title = pgyerMessage.device_type + "蒲公英更新"; StringBuilder builder = new StringBuilder(); builder.append("#### ").append(pgyerMessage.device_type).append("测试包已更新! \n\n") .append("###### version: ").append(pgyerMessage.os_version).append(" | build ").append(pgyerMessage.build_version).append("\n\n") .append("更新内容:\n").append("&gt; ").append(pgyerMessage.notes).append("\n\n") .append("![qr_code_test](图片地址)\n\n") .append("[下载地址](https://www.pgyer.com/你的apk地址) 密码:你的密码\n").append(" @18810100000 @18810100001 @18818100002 "); message.markdown.text = builder.toString(); message.at = new BaseDingMessage.AtBean(); message.at.isAtAll = false; message.at.atMobiles = Arrays.asList("18818100000","18818100001","18818100002"); return message; &#125;&#125; 以上需自行修改内容. 然后创建钉钉机器人.创建四连 1 2 3 4 点此复制钉钉机器人会话token,建立Urls.java. 1234567public interface Urls &#123; /** * 提测群机器人token */ String DING_TEST = "钉钉token";&#125; 此处的Ding_Test即为上面复制的地址 至此,代码主要实现类已经完成,接下来需要去配置蒲公英webhook 配置webhook打开蒲公英应用设置 创建webhook,写入PgyerController的更新请求地址,如果配置与本文的相同,地址则为 1http://你的地址:端口/webhook-1.0-SNAPSHOT/pgyer/update 其中webhook-1.0-SNAPSHOT为war包在tomcat解压后的名称 done! 之后只要上传成功后,即有钉钉消息通知并@测试人员了! 让我们再看下打包后的消息通知! 类似的,代码push,merge也可以做成webhook消息. Github、Gitlab既有成熟的对接机器人.而笔者使用的Coding是没有与钉钉做对接的,此时可自定义机器人实现,有兴趣的同学可参考上面的教程自行实现.]]></content>
      <categories>
        <category>Webhook</category>
      </categories>
      <tags>
        <tag>Dingding</tag>
        <tag>Webhook</tag>
        <tag>Pgyer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux升级Glibc2.14中文乱码]]></title>
    <url>%2Fupdate_glibc_issue%2F</url>
    <content type="text"><![CDATA[CenterOS上默认的Glibc版本为2.12.1,由于我们的Android项目使用到了JNI,将项目构建部署在服务器上时会遇到问题&#39;GLIBC_2.14&#39; not found,那么就需要升级Glibc至2.14.升级的教程网上很多,可是却漏掉了一个步骤,导致后面中文乱码的问题.本篇会做一个全面的解说 1. Glibc下载首先从Glibc Download下载包,这里选择是Glibc 2.14 2. 安装上传至服务器,进入目录解压 1tar zxvf glibc-2.14.tar.gz 进入解压后的目录 1cd glibc-2.14 接着 12345mkdir /opt/buildcd build../configure --prefix=/opt/glibc-2.14make -j4make install 若顺利的话,至此则安装成功了. issue1. 在make install过程中出现错误: 1Can&apos;t open configuration file /opt/glibc-2.14/etc/ld.so.conf: No such file or directory 缺少了报错的编译文件ld.so.conf.通过find命令找到对应的文件配置 然后拷贝文件至对应文件目录,继续编译 12cp /etc/ld.so.conf /opt/glibc-2.14/etc/ make install 编译成功,接着定义下环境变量即可 3. 补充通常的教程至此就结束了.最初笔者参考网上的教程也是做到这里.当时跑程序也没问题,直到前段时间大楼停电,服务器重启后,通过服务器上Jenkins打包上传到蒲公英的中文信息全是乱码! 相当于服务器的编码文件丢失了,所有中文都会乱码. 是因为遗漏了localedata未编译,在服务器重启后,Glibc2.14找不到对应版本2.14的glibc locale文件. 正确操作是,在make&amp;make install完成后继续编译local包 1make localedata/install-locales 编译需要一些时间,完成后重启服务器即可生效 1shutdown -r now 参考: http://blog.csdn.net/clirus/article/details/62425498 参考: http://blog.csdn.net/fzuzhanghao1993/article/details/77650500]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA+Gradle创建MyBatis+SpringMVC项目]]></title>
    <url>%2Fssm_build%2F</url>
    <content type="text"><![CDATA[Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建工具.它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置,抛弃了基于XML的各种繁琐配置. IDEA 全称IntelliJ IDEA,是java语言开发的集成环境,IntelliJ在业界被公认为最好的java开发工具之一,尤其在智能代码助手、代码自动提示、重构、J2EE支持、Ant、JUnit、CVS整合、代码审查、 创新的GUI设计等方面的功能可以说是超常的. 以上为百度的简介.从事Android的童鞋应该不难发现Gradle以及Android Studio的强(hen)大(ka).🤫而AS是基于IntelliJ IDEA开发的.习惯了Gradle的便捷,于是开始基于Gradle+IDEA构建Java项目. 环境准备1. 数据库MySql在MySql Downloads下载对应的版本并安装 此处笔者在macOS上安装5.7.21后打开系统偏好设置,遇到无法加载MySql面板的问题.一番搜索🔍后发现是macOS版本与MySql不兼容,选择低版本的MySql如5.6.39即可. 2. IntelliJ IDEA请自行安(po)装(jie). 3. Tomcat请自行下载解压.如若是macOS或是Linux上解压后需进入bin目录执行下命令chmod u+x *.sh修改权限 创建项目点击 Create New Project 选择基于Gradle的Java Web项目 填写GroupId和ArtifactId 选择gradle.可使用默认的,可使用本地的 接着选择项目目录,基本项目创建好了,接下来进入文件配置 文件配置首先创建java和resources目录,并且创建包以及web.xml. log4j.properties12345678910111213141516171819#设置日志的级别，定义日志信息的输出目的log4j.rootLogger=DEBUG, A1 ,R#定义A1的输出目的地为控制台log4j.appender.A1=org.apache.log4j.ConsoleAppender#布局为 PatternLayout 可以灵活地指定布局模式。log4j.appender.A1.layout=org.apache.log4j.PatternLayout#设置输出格式log4j.appender.A1.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH\:mm\:ss&#125; [%c]-[%p] %m%n#定义R的输出目的地为文件，并且文件大小到达指定尺寸的时候产生一个新的文件log4j.appender.R=org.apache.log4j.RollingFileAppender#设置输出的文件地址log4j.appender.R.File=/Users/xx/Documents/ServerLog#设置文件大小伟100 kb 文件到达100时，产生一个新文件，#MaxBackupIndex 最大记录的文件数为1 查过一个文件删除文件较早的。log4j.appender.R.MaxFileSize=100KB log4j.appender.R.MaxBackupIndex=1#以下和上面一样log4j.appender.R.layout=org.apache.log4j.PatternLayoutlog4j.appender.R.layout.ConversionPattern=%p %t %c - %m%n 以上输出文件地址自行更改 generatorConfig.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;classPathEntry location="$&#123;jarDirection&#125;"/&gt; &lt;context id="mysql" targetRuntime="MyBatis3"&gt; &lt;jdbcConnection driverClass="$&#123;driverClass&#125;" connectionURL="$&#123;connectionURL&#125;" userId="$&#123;userId&#125;" password="$&#123;password&#125;"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver &gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;javaModelGenerator targetPackage="$&#123;modelPackage&#125;" targetProject="$&#123;src_main_java&#125;"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage="$&#123;sqlMapperPackage&#125;" targetProject="$&#123;src_main_java&#125;"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/sqlMapGenerator&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="$&#123;mapperPackage&#125;" targetProject="$&#123;src_main_java&#125;"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 每一个数据库表都对应一个对应的table属性 --&gt; &lt;table tableName="book" domainObjectName="Book"&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; gradle.properties123456# 生成的model类所在包modelPackage=com.lhalcyon.webhook.domain# 生成的mapper接口类所在包mapperPackage=com.lhalcyon.webhook.mapper# 生成的mapper xml文件所在包sqlMapperPackage=com.lhalcyon.webhook.mapper 为了方便扫描,将mapper xml以及接口类放在了同一包下了 😕 jdbc-mysql.properties12345678910# 将jdbc.jarDirection后的内容更改为gradle下载的# mysql-connector-java-5.1.x.jar所在的路径，gradle自动下载的路径如下所示jdbc.jarDirection=/Users/ceyx/.gradle/caches/modules-2/files-2.1/mysql/mysql-connector-java/5.1.38/dbbd7cd309ce167ec8367de4e41c63c2c8593cc5/mysql-connector-java-5.1.38.jarjdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/halcyonjdbc.user=rootjdbc.pass=root 自行填写jdbc.jarDirection路径 build.gradle123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596group 'com.lhalcyon'version '1.0-SNAPSHOT'apply plugin: 'java'apply plugin: 'war'sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;configurations &#123; mybatisGenerator&#125;// 读取config文件夹中对应的配置文件ext&#123; def prop = new Properties(); file("src/main/resources/config/mybatis/jdbc-mysql.properties") .withInputStream &#123; prop.load(it) &#125; file("src/main/resources/config/mybatis/gradle.properties") .withInputStream &#123; prop.load(it) &#125; prop.each &#123; project.extensions.add("$it.key",it.value); &#125;&#125;dependencies &#123; testCompile group: 'junit', name: 'junit', version: '4.12' compile 'org.codehaus.groovy:groovy-all:2.3.11' compile 'jstl:jstl:1.2' compile 'org.springframework:spring-aop:4.2.4.RELEASE' compile 'org.springframework:spring-context:4.2.4.RELEASE' compile 'org.springframework:spring-beans:4.2.4.RELEASE' compile 'org.springframework:spring-web:4.2.4.RELEASE' compile 'org.springframework:spring-webmvc:4.2.4.RELEASE' compile 'org.springframework:spring-tx:4.2.4.RELEASE' compile 'org.springframework:spring-jdbc:4.2.4.RELEASE' compile 'org.springframework:spring-test:4.2.4.RELEASE' compile 'mysql:mysql-connector-java:5.1.38' compile 'org.mybatis.generator:mybatis-generator-core:1.3.2' compile 'org.mybatis:mybatis-spring:1.2.3' compile 'org.mybatis:mybatis:3.3.0' compile 'junit:junit:4.12' compile group: 'commons-dbcp', name: 'commons-dbcp', version: '1.4' compile group: 'org.aspectj', name: 'aspectjweaver', version: '1.8.13' compile group: 'log4j', name: 'log4j', version: '1.2.17' mybatisGenerator 'org.mybatis.generator:mybatis-generator-core:1.3.2' mybatisGenerator 'mysql:mysql-connector-java:5.1.38'&#125;// 利用ant创建一个自动生成MyBatis目录文件的tasktask mybatisGenerate &lt;&lt; &#123; ant.properties['targetProject'] = projectDir.path ant.properties['jarDirection'] = project['jdbc.jarDirection'] ant.properties['driverClass'] = project['jdbc.driverClassName'] ant.properties['connectionURL'] = project['jdbc.url'] ant.properties['userId'] = project['jdbc.user'] ant.properties['password'] = project['jdbc.pass'] ant.properties['src_main_java'] = sourceSets.main.java.srcDirs[0].path ant.properties['src_main_resources'] = sourceSets.main.resources.srcDirs[0].path ant.properties['modelPackage'] = project['modelPackage'] ant.properties['mapperPackage'] = project['mapperPackage'] ant.properties['sqlMapperPackage'] = project['sqlMapperPackage'] ant.taskdef( name: 'mbgenerator', classname: 'org.mybatis.generator.ant.GeneratorAntTask', classpath: configurations.mybatisGenerator.asPath ) ant.mbgenerator(overwrite: true, configfile: 'src/main/resources/config/mybatis/generatorConfig.xml', verbose: true) &#123; propertyset &#123; propertyref(name: 'targetProject') propertyref(name: 'jarDirection') propertyref(name: 'userId') propertyref(name: 'driverClass') propertyref(name: 'connectionURL') propertyref(name: 'password') propertyref(name: 'src_main_java') propertyref(name: 'src_main_resources') propertyref(name: 'modelPackage') propertyref(name: 'mapperPackage') propertyref(name: 'sqlMapperPackage') &#125; &#125;&#125; 接着Sync或者点击Import Changes IDEA就会下载依赖包了.依赖版本号均源于Maven Repository spring-mvc.xml 导入依赖后,则可直接创建spring相关xml 123456789101112131415161718192021222324&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 自动扫描控制器 --&gt; &lt;context:component-scan base-package="com.lhalcyon.webhook.controller"/&gt; &lt;!-- 视图渲染 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/views/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;!-- 控制器映射器和控制器适配器 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源映射器 --&gt; &lt;mvc:resources mapping="/statics/**" location="/WEB-INF/statics/" /&gt;&lt;/beans&gt; applicationContext-dao.xml123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 加载配置文件 --&gt; &lt;context:property-placeholder location="classpath:config/mybatis/jdbc-mysql.properties" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.user&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.pass&#125;" /&gt; &lt;property name="maxActive" value="10" /&gt; &lt;property name="maxIdle" value="5" /&gt; &lt;/bean&gt; &lt;!-- mapper配置 --&gt; &lt;!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;!--&lt;property name="mapperLocations" value="classpath*:com/lhalcyon/mapper/*.xml"/&gt;--&gt; &lt;/bean&gt; &lt;!-- 配置Mapper扫描器 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.lhalcyon.webhook.mapper"/&gt; &lt;/bean&gt;&lt;/beans&gt; applicationContext-service.xml1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 配置包扫描器 --&gt; &lt;context:component-scan base-package="com.lhalcyon.webhook.service"/&gt;&lt;/beans&gt; applicationContext-trans.xml1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 数据源 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:method name="insert*" propagation="REQUIRED" /&gt; &lt;tx:method name="delete*" propagation="REQUIRED" /&gt; &lt;tx:method name="update*" propagation="REQUIRED" /&gt; &lt;tx:method name="query*" propagation="SUPPORTS" read-only="true" /&gt; &lt;tx:method name="get*" propagation="SUPPORTS" read-only="true" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 切面 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* com.lhalcyon.webhook.service.*.*(..))" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt; &lt;!-- 初始化spring 容器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring/applicationContext-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;index-dispather&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:config/spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;index-dispather&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 解决post乱码问题 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; Tomcat部署Run-&gt;Edit Configurations 有fix项点击配置即可,然后运行. MyBatis配置数据库管理工具笔者使用的是 首先创建数据库halcyon,接着创建book表,用于后面的mybatis generator 12345CREATE TABLE book ( book_id INT PRIMARY KEY AUTO_INCREMENT, book_name VARCHAR(30) NOT NULL, author VARCHAR(20) default '佚名') 然后在gradle创建mybatis generator task 运行task 运行成功后,会生成与数据库表对应的java bean与dao文件,即项目里的Book.java、BookExample.java、BookMapper.xml、BookMapper.java generatorConfig.xml配置参数可自行搜索补充修改🤔.手动覆写下Book的toString方法方便日志输出 测试为了满足同时测试Spring、SpringMVC、Mybatis,笔者建立一个Controller通过Get请求进行CURD操作. Service1234567891011121314151617181920212223242526272829@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired private BookMapper bookMapper; @Override public void insertBook(Book book) &#123; bookMapper.insert(book); &#125; @Override public void updateBook(Book book) &#123; bookMapper.updateByPrimaryKey(book); &#125; @Override public List&lt;Book&gt; getAllBooks() &#123; BookExample example = new BookExample(); return bookMapper.selectByExample(example); &#125; @Override public void deleteBookById(int bookId) &#123; BookExample example = new BookExample(); example.createCriteria().andBookIdEqualTo(bookId); bookMapper.deleteByExample(example); &#125;&#125; Controller1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@RestControllerpublic class BookController &#123; private static final Logger logger = Logger.getLogger(BookController.class); @Autowired private BookService bookService; @RequestMapping(value = "/insert",method = RequestMethod.GET) public String insert(String bookName,String author)&#123; Book book = new Book(); book.setBookName(bookName); book.setAuthor(author); bookService.insertBook(book); return queryStrings(); &#125; @RequestMapping("/update") public String updateAuthor(int bookId,String bookName,String author)&#123; Book book = new Book(); book.setBookId(bookId); book.setBookName(bookName); book.setAuthor(author); bookService.updateBook(book); return queryStrings(); &#125; @RequestMapping("/delete") public String deleteBook(int bookId)&#123; bookService.deleteBookById(bookId); return queryStrings(); &#125; @RequestMapping("/find_all") public String getAllBooks()&#123; List&lt;Book&gt; books = bookService.getAllBooks(); logger.info(books); return books.toString(); &#125; private String queryStrings()&#123; List&lt;Book&gt; allBooks = bookService.getAllBooks(); return allBooks.toString(); &#125;&#125; 直接通过请求地址,获得结果 插入: 1http://localhost:8080/webhook/insert?bookName=java&amp;author=jack 执行后直接将数据库中所有book记录输出,方便观察. 其它操作类似 更新: 1http://localhost:8080/webhook/update?bookId=3&amp;bookName=go&amp;author=joe 删除: 1http://localhost:8080/webhook/delete?bookId=4 查询(所有): 1http://localhost:8080/webhook/find_all 如若发生500 Invalid bound statement (not found)类似错误,一般是没有扫描到Mapper.xml.其中一种情况下是xml根本没被打包进war.需要在build.gradle中进行配置,并且配置后Sync或Import Changes,再重新用命令./gradlew build才可生效. 123456//将src文件夹中的资源文件同时打包processResources &#123; from(&apos;src/main/java&apos;) &#123; include &apos;**/*.xml&apos; &#125;&#125; 至此SpringMVC+MyBatis+Gradle项目已经构建测试完毕. 代码已上传GayHub,文章若对各位大佬有帮助,麻烦顺手点个star~ ❤️ 各位可能发现了,SSM配置起来比较繁琐,相比之下,SpringBoot就精简了许多.后面有机会,我们再来细说 🤒 参考: https://www.cnblogs.com/bojuetech/p/5844413.html 参考: http://blog.csdn.net/kingboyworld/article/details/78251425]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IntelliJ</tag>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio版本兼容Api警告]]></title>
    <url>%2Fas_warning%2F</url>
    <content type="text"><![CDATA[Android Studio版本兼容Api警告最近在开发中,组内的小伙伴在开发中使用了高版本SDK25的Api,但是我们的项目最低兼容14,因此测试在5.1上的手机直接就崩溃了,问其在开发中没有看到警告吗,回复说确实没看到.后来查究一下,他的工具上确实没有显示.本文简述下如何手动去调整兼容Api的提示等级,避免在开发中用到高版本的Api却不自察. 首先win电脑是打开Android Studio的 Setting ,mac是打开Android Studio的 Preferences 选择Editor中的Inspections 对Calling new methods on older versions进行勾选并且配置为Error级别 如此简单即可搞定.如遇到其他警告,错误代码没提示也可类似进行操作配置.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode代码提示问题处理]]></title>
    <url>%2Fxcode-idiot%2F</url>
    <content type="text"><![CDATA[最近在写Swift.对于笔者这种被JetBrains的几大IDE工具给惯坏的开发者,Xcode的代码提示真是无力吐槽,先不论智能提示度,就连基本的提示也经常出不来.这里就简单总结下iOS同事传授的几招解决办法 1.Clean Project最直接的办法就是清空项目. 可视化按钮入口再哪请自行查找,笔者一般是用Command+Shift+K进行清空,此方法一般有效,缺点是会重新编译项目,比较慢 2.清空Xcode缓存前往Xcode的缓存目录,清空项目编译缓存. 具体操作为右键Finder前往文件夹文件夹路径为/用户/ceyx/资源库/Developer/Xcode/DerivedData 其中ceyx 替换为自己的用户名,删除目录下所有文件,然后重新打开Xcode,编译. 此方法比1更慢,往往也更有效 3.终极大招如若上述两种方法还无效,只能使用绝招了…重启Xcode,还不行就重启电脑… 笔者黔驴技穷了,只能充当下网吧老板传授下终极大招.👻 题外话,对于JetBrains出品的appcode还未尝试过,不知对于Xcode项目兼容到何程度,是否支持Cocoapod等,有时间会去体验下,希望至少在代码提示上能更友善些😀 笔者去体验了下Appcode,其代码提示和快捷键如Jetbrains其他产品一样非常智能,但是代码中偶有飘红,却可以成功运行,比较干扰编码.尤为尴尬的一点是,Appcode不支持storyboard,即在项目内点开storyboard文件就直接跳转xcode了😥. 如真的被Xcode逼疯的童鞋可以考虑下用AppCode编码,用Xcode操作storyboard]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux+Jenkins+Gradle构建Android参数化自动打包(二)]]></title>
    <url>%2Flinux-jenkins-gradle_build_android2%2F</url>
    <content type="text"><![CDATA[在前一篇文章中,说明了在CenterOS上进行一系列的环境搭建,本文开始说明关于项目的一系列配置 Jenkins项目配置首先创建一个项目,将构建保持的天数和个数进行限制 此处感谢后台同事提示,因为Android SDK NDK 就特别占空间了,如果构建缓存不进行限制,则很快服务器空间就会不足🤥 参数构建配置打包环境 分支指定 email自定义接收者 打包时间戳 因为笔者的公司对打包的Apk名以及测试版本号时间戳显示的要求,因此需要使用动态参数 还有其他参数均与以上类似,可自行配置 !!! 记住尤为重要的是这些参数都是Jenkins上配置的Gradle属性,得传递到App的Gradle中 这里勾选Pass all job parameters as Project properties 源码管理在源码管理处配置Git账号 这里的*/${BRANCH}对应参数配置时的BRANCH.为什么这里做成选择型参数呢,是因为分支名是未知的,做成填写的话,可能压根拉不到指定分支的代码🤐 Gradle构建脚本增加构建动作 这里${WORKSPACE}指的是Git拉下的根目录.途中马赛克位置则为项目根目录 蒲公英上传增加构建动作,将Apk上传蒲公英 1curl -k -F &quot;file=@$&#123;WORKSPACE&#125;/source/项目根目录/app/apks/$&#123;BUILD_PREFIX&#125;_$&#123;JENKINS_TIME&#125;_$&#123;DAY_VERSION&#125;.apk&quot; -F &quot;uKey=你的ukey&quot; -F &quot;_api_key=你的apiKey&quot; -F &quot;installType=2&quot; -F &quot;password=下载密码&quot; -F &quot;updateDescription=$&#123;DESCRIPTION&#125;&quot; https://www.pgyer.com/apiv1/app/upload ${WORKSPACE}/source/项目根目录/app/apks/为笔者自行修改的Apk输出目录,此处请根据自己的项目输入目录进行修改 curl命令如果使用不了可自行百度解决 以下为蒲公英的上传Api,可以自行调整参数 邮件通知首先还是进入Jenkins-&gt;系统设置 在Jenkins Location中进行配置 Jenkins URL:http://10.50.0.16:8777/jenkins/ 系统管理员邮件地址: Android参数化构建&lt;aaa@163.com&gt; 此处Android参数化构建就为邮件中的发送人名称 系统设置中的默认收件人最好不要配置为自己,因为如果配置后,自己就永远在收件人的前端,后面想发送给领导时,便不大好. 邮件的内容可自定义html内容,二维码直接线下生成蒲公英的地址然后贴在邮件内即可 App本地Gradle配置首先在gradle.properties文件中进行参数化构建在非Jenkins写入情况时的缺省值配置 在未使用Jenkins构建的情况下应用会读本地的这些变量值 然后在appmodule下的build.gradle中进行配置写入的值配置 12345678910111213141516171819202122232425262728293031323334//修改生成的apk名字及输出目录applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def newName def oldFile = output.outputFile def outDirectory = oldFile.parent def buildPrefix def showVersion if (variant.buildType.name == &apos;debug&apos;) &#123; buildPrefix = BUILD_PREFIX &#125; else &#123; buildPrefix = BUILD_PREFIX_RELEASE &#125; def jenkinsTime = JENKINS_TIME if (variant.buildType.name == &apos;debug&apos;) &#123; showVersion = buildPrefix + &apos;_&apos; + jenkinsTime + &apos;_&apos; + DAY_VERSION &#125; else &#123; showVersion = APP_VERSION &#125; resValue(&quot;string&quot;, &apos;fund_app_version&apos;, showVersion) def tempFile = file(&quot;build.gradle&quot;) outDirectory = tempFile.parent + &apos;/apks&apos; if (IS_JENKINS) &#123; newName = buildPrefix + &apos;_&apos; + jenkinsTime + &apos;_&apos; + DAY_VERSION + &apos;.apk&apos; &#125; else &#123; newName = &apos;android-v&apos; + APP_VERSION + &apos;-&apos; + variant.productFlavors[0].name + &apos;-&apos; + variant.buildType.name + &apos;.apk&apos; &#125; output.outputFile = new File(outDirectory, newName) &#125;&#125; 系统默认的输入路径是在build文件夹中,层级比较深.此处笔者将apk的输出路径进行了修改并且对apk的输出名称进行了调整 至此,Jenkins参数自动化构建已经完成!😀]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>Android</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux+Jenkins+Gradle构建Android参数化自动打包(一)]]></title>
    <url>%2Flinux-jenkins-gradle_build_android1%2F</url>
    <content type="text"><![CDATA[前言关于Jenkins部署安卓自动打包有很多好处,可以配置参数进行构建,选择打包环境、设置App版本、设置加密开关等.起初,笔者也是参考了一些网上的教程,将自动化打包构建在了自己的windows开发机器上,而将Jenkins自动构建Android部署在服务器上和本机上在环境构建方面略有不同,坑略多. 参数化构建的过程却是很便捷,但是部署在本机上自动化打包其实是个会增加打包时长的工作,因为自动化打包会首先去代码仓库拉取代码到本地,然后再开始打包,这个过程会比直接用AS打包慢很多.后来提出需求,要将自动化打包配置到服务器上.运维就提供了一台Linux服务器,并且上面已配置后台的自动化打包环境,用的是Jdk1.7和比较旧版本的Jenkins,于是我们得另行使用独立的安装的环境. 最终结果最终我们要实现的是实现Jenkins上面配置应用版本号、Git分支、应用渠道、请求基地址、应用环境等参数,进行一键参数化构建打包上传至蒲公英并发送邮件通知给自定义的接收者 最终实现参数化配置大致如下所示: 发送邮件(邮件内容较长,进行了相应缩小) 环境搭建所需环境 新版Jenkins(需能安装参数化构建插件) Tomcat 新版Jenkins Android SDK Android NDK aapt Git Gradle 其它(视自身项目所需) CenterOS64位已有环境 Jdk1.7 Tomcat 旧版Jenkins 1. Jdk安装及配置由于Android开发使用的 Jdk1.8,因此不能复用服务器上现有的Jdk 首先去Oracle Downloads下载 Jdk for Linux.笔者下载的是jdk-8u131-linux-x64.tar.gz 上传到服务器,进入相关目录解压 1tar -zxvf jdk-8u131-linux-x64.tar.gz 可将目录移至其他目录.其实最好在解压前就将压缩包移至目标目录 Jdk环境变量配置(可选) 由于后台使用了JAVA_HOME、JENKINS_HOME等一系列环境变量名,所以服务器上默认调用的会是他们的环境变量,我们开发的一套只能在自己的Tomcat、Jenkins中进行指定,具体下文会进行说明 2. Tomcat安装及配置首先去Tomcat Download选择版本进行下载.这里笔者选择的是apache-tomcat-7.0.79.tar.gz 上传到服务器,进入相关目录解压 1tar -zxv -f apache-tomcat-7.0.79.tar.gz a.端口修改由于常规tomcat端口被已有tomcat占用,因此我们需要修改端口 进入conf目录下的server.xml修改,此处笔者是用Vim修改.不会用的同学请出门左转度娘🤔 主要修改的是,设置为自定义端口号 Tomcat admin port 即文件最上面的端口号 Http/1.1 port 连接访问的端口号 AJP/1.3 port b.环境配置指定Tomcat运行时环境,在bin目录下修改setclasspath.sh 以下是笔者的环境,请自行替换路径 123export JAVA_HOME=/usr/android/java/jdk1.8.0_131export JRE_HOME=/usr/android/java/jdk1.8.0_131/jreexport JENKINS_HOME=/home/android/jenkins 3. Gradle安装及配置首先去Gradle Download下载对应Gradle版本,笔者使用到的是gradle-3.3-all.zip 上传到指定目录解压 1unzip gradle-3.3-all.zip 然后添加环境变量vim /etc/profile,在环境变量配置处增加一句 1export GRADLE_HOME=/home/gradle-3.3/bin 4. Android Sdk For Linux 安装及更新这里下载Sdk解压都不是难点.难点在于安装之后更新的问题. 用AS或者Eclipse的同学肯定接触过Sdk Manager,此处选择更新后要手动点Accept License才能启动更新.但是在Linux下没有界面化的勾选可用.因此需要用脚本来更新.网上有说复制License的方法笔者试了无效,也许是姿势不对吧,此处也是踩了很久的坑才搜出来的解决方法: 更新Sdk方法传送门 这里先感谢下该作者👏 这里也为不愿跳传送门的同学说明一下,就几个步骤. a.查看可更新列表 在Sdk的tools目录使用./android list sdk --all查看远程服务器提供的Sdk包的序号,记录想要更新的Sdk序号 b.编辑脚本 1234567#!/usr/bin/expectset timeout -1spawn /usr/local/android-sdk-linux/tools/android update sdk -u -a -t 1,2,3,24,25,26,27,28,30,95,96,102,103,104,105,106,107expect &#123; &quot;Do you accept the license&quot; &#123; exp_send &quot;y\r&quot; ; exp_continue &#125; eof&#125; 此处1,2,3,...为需要下载的Sdk序号 c.运行脚本 待脚本跑完,sdk就更新完毕了 注意此处脚本用到了expect,需要在服务器上安装,此处提供expect安装传送门 5. Ndk for Linux安装安装较简单,后续需配置Jenkins系统变量,下文会进行说明 项目因用到了Jni,需要安装Ndk,可是后期发现在项目里每次均去编译jni导致项目的compile sdk不能使用高于23的,致使Instant Run等功能使用,很影响开发效率.后期改在项目外编译好了静态库然后放入项目中,这样不会限制项目自身的SDK版本,因此若未使用JNI的项目,则可跳过此步骤 6. Git安装及环境变量配置下载安装并配置环境变量 1export GIT_HOME=/usr/android/git-2.12.2/bin 7. Jenkins安装及配置a. 下载下载Jenkins将war包放入Tomcat的webapps目录下,启动tomcat 然后在地址栏输入路径http://localhost:/8777 其中8777为第二步中自定义的端口号 b. 插件安装然后安装插件(基本参考网上的) 12345678910111213141516171819202122231.Branch API Plugin2.build timeout plugin3.build-name-setter4.Credentials Binding Plugin5.description setter plugin6.Dynamic Parameter Plug-in7.Environment Injector Plugin9.Git plugin10.GIT server Plugin11.Gradle Plugin12.Git Parameter Plug-In13.Pipeline: Basic Steps14.Pipeline: Build Step15.Pipeline: Input Step16.Pipeline: Nodes and Processes17.Pipeline: Stage Step18.Scriptler19.Workspace Cleanup Plugin20.Post-Build Script Plug-in21.Email Extension Plugin22.SSH Slaves plugin23.Timestamper(不明为什么少8) 因为Jenkins版本不同,实际使用中发现缺失不少 以下附上笔者所安装的所有插件(若无问题的可跳过) c. 环境变量配置环境变量 首先点击系统管理-&gt;系统设置配置Jdk、Android Sdk、Gradle、Android Ndk环境变量(此处也可配置Git目录,笔者是将Git目录配置在Linux环境变量中了) 其它如邮件相关配置的在下篇会说明 至此环境大体上配置已经完成,下篇即可进入项目相关配置]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>Android</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[混编:Swift调用Objective-C]]></title>
    <url>%2Fhybrid-compile_swift2oc%2F</url>
    <content type="text"><![CDATA[环境 Xcode 8.3.3 Swift3.+ 步骤1.创建混编桥接头文件 名称随便取,最好能和普通header文件做区别 2.项目配置桥接文件 点击工程,选中Build Settings,子选项勾选All 在下面配置中找到(或者搜索)Swift Compile - General 配置混编桥接头文件 点开图中红圈区域进行配置,如我所建的文件在工程里路径为MyProject/Hybrid-Compile.h 则配置也应是这个路径 保存后在该头文件中引用相应OC类头文件即可在Swift中调用 引用注意如果是项目内的OC文件直接引用即可 如果是Pod引用的库中的OC文件则需要带上其Pod中的路径]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
</search>
